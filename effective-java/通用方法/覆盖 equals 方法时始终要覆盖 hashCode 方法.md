# 覆盖 equals 方法时始终要覆盖 hashCode 方法
#Java 

在每个覆盖 equals 方法的类中，都必须要覆盖 hashCode 方法。如果不这样做，就违反了 hashCode 通用约定，从而导致该类无法结合所有基于散列值的集合一起工作。

Object 中存在以下规范：
1. 程序运行期间，只要实例的 equals 方法所用到的关键属性没有更改，在同一实例上调用 hashCode 方法始终返回同一个值。
2. 如果两个实例调用 equals 方法是相等的，则调用两个实例的 hashCode 都必须产生相同的结果。
3. 如果两个实例根据 equals 方法比较是不相等的，则调用这两个实例的 hashCode 方法时，无需产生不一样的结果。

> 虽然 Object 不要求不同的实例调用 hashCode 方法必须返回不同的值，但程序员需要知道尽可能产生不同值的散列函数可以提升性能。

在覆盖 equals 方法时没有覆盖 hashCode 方法时，会违反第 2 条规范。在 HashMap 等依赖散列值的容器中，调用 get 方法会无法获取实例，即使两个实例在逻辑上是相等的。

## 提供优秀的 hashCode 方向

覆盖 hashCode 方法虽然可以解决 HashMap 中，在插入键值对后使用同一键调用 get 方法为 null 的问题，但是设计粗糙的散列函数会增加任务的运行时间。

例如，糟糕的散列函数：

```java
@Override
public int hashCode() {
	return 42;
}
```

例子中的 hashCode 方法虽然合法，也确保相同的对象具有相同的散列值，但也使得每个对象的散列值是相同的。在使用 HashMap 容器时，所有元素都映射到同一个散列通中，会使得 HashMap 退化成一个链表，本该线性时间运行的程序变为平方级时间运行。

## 编写 hashCode 方法诀窍

好的散列函数通常倾向于“为不同的对象生成不相等的散列值”。