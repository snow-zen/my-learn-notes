# 对性能的思考
#Java #Multithreading 

资源的定义非常宽泛，例如：

+ CPU 时钟周期。
+ 内存。
+ 网络带宽。
+ I/O 带宽。
+ 数据库请求。
+ 磁盘空间。
+ 其他资源。

当操作性能由于某种特定的资源而受限制时，通常将该操作称为资源密集型的操作。例如：CPU 密集型、I/O 密集型等。

多线程相比单线程总会引入一些额外的性能开销。例如：

+ 线程之间的协调（加锁、触发信号、内存同步）。
+ 上下文切换。
+ 线程的创建和销毁。
+ 线程的调度。

过度使用多线程会导致这些开销会超过由于提高吞吐量、响应性或者计算能力所带来的性能提升。一个并发设计糟糕的程序，其性能甚至比实现相同功能的串行程序的性能还要差。

通过并发提高性能，需努力做好两件事：

1. 更有效的利用现有资源处理任务。
2. 出现新的处理资源使程序尽可能地利用这些新资源。

> 从性能监视视角看，CPU需要尽可能保持忙碌的状态。

## 性能和可伸缩性

衡量程序的性能可以有多个指标，例如：

+ 服务时间。
+ 延迟时间。
+ 吞吐率。
+ 效率。
+ 可伸缩性。
+ 容量。

其中服务时间、等待用于衡量某个指定的任务单元需要“多快”才能处理完成。另一些指标生产量、吞吐量用于在计算资源一定的情况下，能完成“多少”工作。

**可伸缩性**指增加计算资源时，程序的吞吐量或者处理能力能相应地增加。在针对可伸缩性进行性能调优时，其目的通常是用更小的代价完成相同的工作。

性能的两个方面 —— “多快”和“多少”，是完全独立的，有时甚至是相互矛盾的。在日常开发中应用分层是常见的编程模型，例如 MVC 模型。这种分层模型在提高可伸缩性的同时通常会造成性能损失，而单一的程序避免了在不同层次之间传递任务时存在的网络延迟、同时也不需要将计算过程分解到不同的抽象层次，因此能减少许多的开销。

但单一的程序在到达自身处理极限时，会遇到提升处理能力非常困难的问题。因此我们通常会接受每个工作单元执行更长的时间或消耗更多的计算资源，以换取应用程序在增加更多资源的情况下处理更高的负载。

## 评估各种性能权衡因素

在几乎所有的工程决策中都会涉及某些形式的权衡。尽管在软件工程的决策中通常不会涉及资金以及人身安全，但在做出正确的决策时通常会缺少相应的信息。

例如要实现一个高效的排序算法，那么需要知道被处理数据集的大小，还有衡量优化的指标。因此大多数优化措施都不成熟的原因之一：它们通常无法获得一组明确的需求。

避免不成熟的优化。首先使程序正确，如果它运行得不够快然后再提高运行速度。当进行决策时，有时候会通过增加某些形式的成本来降低另一种形式的开销。许多性能优化措施通常都是以牺牲可能性或可维护性为代价。有时候，优化会破坏面向对象的设计原则。因此如果你无法找出其中的代价或风险，那么或许还没有对这些优化措施进行彻底的思考和分析。

大多数决策中都包含多个变量，且非常依赖运行环境。在使某个方案比其他方案“更快”之前，首先问自己一些问题：

+ “更快”的含义是什么？
+ 方法在什么条件下运行得更快？在低负载还是高负载的情况下？大数据集还是小数据集？能否通过测试结果来验证你的答案？
+ 条件在运行环境中的发生频率？能否通过测试结果来验证你的答案？
+ 在其他不同条件的环境中能否使用这里的代码？
+ 实现这种性能提升时，需要付出哪些哪些隐含的代价？这种风险是否合适？

> ⚠️ 注意：对性能的提升可能是并发错误的最大来源。有人认为同步机制“太慢”，因而采用一些看似聪明实则危险的方法来减少同步的使用。

由于并发错误是最难追踪和消除的错误，因此对于任何可能会引入这类错误的措施，都需要谨慎实施。虽然你的初衷可能是用安全性来换取性能，但最终可能什么都得不到。

性能调优时，需要有明确的性能需求，需要测试程序以及真实的配置和负载等环境。在对性能调优后，需要再测量以验证是否达到了预期的性能提升目标。一切以测试为基准，不要猜测。

市场上有成熟的分析工具用于评估性能以及找出性能瓶颈，但你不需要花太多的资金来找出程序的功能。例如，免费的 perbar 程序可以给出 CPU 的忙碌程度信息。



