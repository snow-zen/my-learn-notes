# MVCC 多版本并发控制
#MySQL 

大多数数据库系统都实现了 MVCC，但各自的实现机制不尽相同，因为 MVCC 并没有一个统一的实现标准。

可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

## 实现细节

MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。每个事务开始时，会对数据进行快照，不管事务的执行时间多长，它所看到的数据都是一致的。

InnoDB 的 MVCC，是通过在每行记录后保存两个隐藏的列来实现的。这两个列，一个保存行的创建时版本号，一个保存行删除时版本号。而存储的 “时间” 实际上是系统版本号。每开始一个新的事务，系统版本号都会自动递增。

事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。MySQL 在默认的 REPEATABLE READ 隔离级别下，MVCC 有如下操作：

+ **SELECT**：InnoDB 会根据以下两个条件检查每行记录：
	1. InnoDB 只查找版本号小于等于当前事务版本号的数据行，这样可以确保事务读取的行，要么是事务开始前已经存在的，要么是事务自身插入或者修改过的。
	2. 行的删除时版本号要么未定义，要么大于当前事务版本号。可以确保事务读取到的行，在事务开始之前未被删除。
+ **INSERT**：InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。
+ **DELETE**：InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。
+ **UPDATE**：InnoDB 为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。

MVCC 只在 REPEATABLE、READ COMMITTED 两个隔离级别下工作。其他两个隔离级别都和 MVCC 不兼容，因为 READ UNCOMMITTED  总是可以读取到最新的数据行，而不是符合当前事务版本的数据行，而 SERIALIZABLE 则会对所有读取的行都进行加锁。