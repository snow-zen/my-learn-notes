# 避免性能测试的陷阱
#Java #Multithreading 

理论上，找出一个典型的使用场景，编写一段程序多次执行使用场景，并统计执行时间。但在实际上，必须提防多种编码陷阱，它们会使性能测试变得毫无意义。

## 垃圾回收

垃圾回收的执行时序是无法预测的，因此在执行测试时，垃圾回收器可能在任何时候运行。有两种策略可以防止垃圾回收器对测试结果产生偏差。

第一种策略是，确保垃圾回收器在整个测试过程中都不执行。可通过制定 `-verbose:go` 来判断是否执行了垃圾回收操作。

第二种策略是，确保垃圾回收操作在测试期间执行了多次，这样测试程序就能充分反映出运行期间的内存分配与垃圾回收等开销。

> 推荐使用第二种，它要求更长的测试时间，并且更有可能反映出运行期间的内存分配与垃圾回收等开销。

## 动态编译

与 C++ 之类的静态编译语言相比，Java 这种动态编译语言的性能基准测试要困难的多。在 HotSpot JVM 等现代 JVM 中将字节码的解释与动态编译结合起来使用。当类被第一次加载时， JVM 通过解译字节码的方式来执行它。当某个时刻，如果一个方法运行的次数足够多，那么动态编译器会将它编译为机器代码，当编译完成后，代码的执行方式将从解释执行变为直接执行。

这种编译的执行时机是无法预测的，且编译后的代码会对测试结果带来巨大的偏差，同时基于各种原因，代码还可能被反编译以及重新编译。例如：加载了一个会使编译假设无效的类，或者在收集了足够的分析消息后，决定采用不同的优化策略来重新编译某条代码的路径。

通过使程序运行足够长的时间可以防止动态编译对测试结果产生的偏差，因为编译过程以及解释执行都只是总运行时间的很小一部分。

另一种方式是使代码预先运行一段时间并且不测试这段时间内的代码性能，这样在开始计时前代码就已经被完成编译了。HotSpot 中运行程序时，使用 -xx:+PrintCompilation，那么当动态编译运行时将输出一条信息，通过信息验证动态编译是在测试运行前，而不是运行过程中执行。

也可以通过在 JVM 中将相同的测试运行多次，可以验证测试方法的有效性。其中第一组结果应该作为“预先执行”的结果而丢弃。如果剩下的结果中仍然存在不一致的地方，那么就需要进一步对测试进行分析，从而找出结果不可重复的原因。

## 对代码路径的不真实采样

运行时编译器根据收集到的信息对已编译的代码进行优化。有时 JVM 可能会基于一些只是临时有效的假设进行优化，并在这些假设失效时抛弃已编译的代码。因此，测试程序不仅要大致判断某个典型应用程序的使用模式，还需要尽量覆盖在该应用程序中将执行的代码路径集合。

## 不真实的竞争程度

并发应用程序可以交替执行两种不同类型的工作：访问共享数据、执行线程本地计算。

为了保证测试的真实性且有意义，可以使工作线程尽量模拟应用程序中线程本地计算量以及并发协调开销。否则工作线程没有执行太多工作，因此吞吐量将受限于线程之间的协调开销。

## 无用代码的消除

编写优秀的基准测试程序时，要面对的挑战是：优化编译器能找出并消除那些不会对输出结果产生任何影响的无用代码。

由于基准测试通常不会进行计算，因此它们很容易在编译器的优化过程中被消除。对于大多数情况下，编译器从程序中删除无用代码都是一种优化措施，但对于基准测试程序来说却是一个大问题，因为这将使得被测试的内容变得更少。

在 HotSpot 中，许多基准测试在“-server”模式下都能比在“-client”模式下运行更好，因此无论在正式产品还是测试版本中，都应该选择 -server 模式而不是 -client 模式 —— 只是在测试程序时必须保证它们不会受到无用代码消除优化的影响。

要编写有效的性能测试程序，就需要告诉优化器不要将基准测试当作无用代码而优化掉。这就要求程序中每个计算结果都要通过某种方式来使用，这种方式不需要同步或大量的计算。