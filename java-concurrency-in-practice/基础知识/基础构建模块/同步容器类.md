# 同步容器类
#Java #Multithreading 

同步容器类包括 Vector 和 Hashtable，二者是早期 JDK 的一部分，此外还包括 JDK 1.2 中添加一些功能类似的功能，这些同步的封装类是由 Collections.synchronizedXxx 等工程方法创建的。

这些类实现线程安全的方式是：将自身状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程访问状态。

## 同步容器类的问题

虽然同步容器会对每个公有方法都进行同步，但在某些情况下可能需要额外的客户端加锁来保护复合操作。常见的复合操作：

+ 迭代（遍历容器中所有元素）。
+ 跳转（根据指定顺序访问当前元素的下一个元素）。
+ 条件运算（例如：若没有则添加）。

由于这些复合操作需要客户端额外进行加锁，因此同步容器需要告知客户端使用的锁。

## 迭代器

容器中迭代的正确性要依赖运气，只有在迭代时不修改元素才能保证迭代的正确性，如果迭代中途修改元素则即使在单线程环境下也会抛出异常。

> 我们可以通过在客户端加锁来解决不可跌倒的问题，但是需要牺牲一些伸缩性。同时，在迭代时持有锁，会降低容器的并发性。

## ConcurrentModificationException

无论早期的容器类还是现代容器都没有消除复合操作的问题。以迭代为例，不论是直接迭代还是 for-each 语法，对容器迭代的标准方式都是使用 Iterator。然而在遇到兵法修改的问题时，采用的是“及时失败（fail-fast）”错误，在迭代时修改容器元素会抛出 `ConcurrentModificationException` 异常。

“及时失败”机制并不是一种完备的处理机制，而只是“善意地”捕获并发错误，因此只能作为并发问题的预警指示器。“及时失败”机制的实现方式是将计数器和容器关联起来：如果在迭代器期间计数器被修改，那么迭代将抛出 `ConcurrentModificationException` 异常，然而检查是在没有同步下进行，因此可能会看到失效的值，造成迭代器没有意识到已经发生了修改。

> 这是一种设计上的权衡，从而降低并发修改操作的检测对程序性能的影响。

在并发环境下，对迭代操作加锁会降低程序的并发性，尤其在容器规模很大时或单个元素执行操作过长时，锁的竞争会更加激烈，许多的线程都在等待锁的释放，那么将极大的降低吞吐量和 CPU 的利用率。

如果不希望在迭代时对容器加锁，那么替代方法就是“克隆”容器。在克隆的副本上进行迭代，由于副本使用线程封闭，因此其他线程不会在迭代期间修改到副本元素。但是克隆同时也会带来显著的性能消耗，具体使用请根据需求进行选择。

> ⚠️ 注意：虽然可以通过加锁的方式防止迭代时抛出 `ConcurrentModificationException` 异常，但需要在所有迭代的地方进行加锁，但有时一些隐藏迭代如List的toString方法容易被忽视。

