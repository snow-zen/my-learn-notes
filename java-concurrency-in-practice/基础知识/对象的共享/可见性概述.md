# 可见性概述
#Java #Multithreading 

一种常见的误解是，认为关键字 synchronized 只能用于实现原子性或者确定“临界区”。同步还有另一个重要的方面：**内存可见性**。

可见性是一种复杂的属性，常常会违背人们的直觉。通常情况下，我们无法确保多线程环境下读线程适时的看到其他线程写入的值，有时甚至是不可能的值。因此，为了保证多个线程对内存写入操作的可见性，则必须使用同步机制。

例如，在另一个线程打印变量：

```java
public class NoVisibility {

    private static boolean ready;
    private static int number;

    public static void main(String[] args) {
        new Thread(() -> {
            while (!ready) {
                Thread.yield();
            }
            System.out.println(number);
        }).start();

        number = 42;
        ready = true;
    }
}
```

在没有同步机制的情况下，或许可能由于编译器“重排序”的原因无法保证程序中的操作会按照指定顺序执行，最后无法得出正确的结论：

![多线程中指令重排下结果不可预测](https://my-images-repo.oss-cn-hangzhou.aliyuncs.com/java-concurrency-in-practice/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E4%B8%8B%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%8F%AF%E9%A2%84%E6%B5%8B.png)

重排序虽然看上去是一种失败的设计，但也存在优点：

+ JVM 可充分利用现代多核处理器的强大性能。
+ 在缺少同步情况下，允许编译器对操作顺序进行重排序，并将数值缓存在寄存器中。
+ 在保证结果一致性下，允许 CPU 对操作顺序进行重排序，并将数值缓存在处理器特定缓存中。

由于缺少同步机制下重排序会将数值缓存在 CPU 的寄存器中，所以在现代多核心 CPU 下执行多线程任务时会出现数据可见性问题。因此，只要有数据在多个线程之间共享，则必须使用正确的同步即可避免这种情况发生。

## 失效的数据

在缺乏同步程序的情况下，可能产生失效数据。即线程所读取到的是一个失效的值，除非在线程访问变量时都使用同步。更糟糕的是，失效值不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。

失效的数据可能导致一些令人困惑的错误：

+ 意料之外的异常。
+ 被破坏的数据结构。
+ 不精确的计算以及无线循环。

## 非原子的 64 位操作

当线程在没有同步的情况下读取变量时，可能会得到一个失效的值，但至少是之前其他某个线程设置的值，而不是一个随机值。

> 这种安全性保证也被称为最低安全性保证。

Java内存模型要求变量的读取和写入都必须是原子操作，因此最低安全性保证适用于绝大多数变量，但也存在例外：long 和 double 这类 64 位数值变量。

由于历史发展原因，早期的 CPU 还不能有效的支持64位原子性操作。因此对于非 volatile 类型的 long 或 double 变量，JVM 允许将 64 位的读取和写入分解位高 32 位和低 32 位操作进行。因此这可能造成多线程下数据错误，除非使用 volatile 声明变量或用锁进行同步。

> 注意：对于使用 32 位 JVM 的程序，在使用 long 或 double 类型共享变量时一定要使用 volatile 声明变量或用锁进行同步。

## 加锁与可见性

内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。即通过 Happens-Before 原则保证同一锁上解锁前的操作必定在另一线程加锁操作前执行：

![内置锁 Happens-Before 原则](https://my-images-repo.oss-cn-hangzhou.aliyuncs.com/java-concurrency-in-practice/%E5%86%85%E7%BD%AE%E9%94%81Happens-before%E5%8E%9F%E5%88%99.png)

例图中，在线程 A 释放锁 M 前的所有操作结果对于线程 B 获得锁 M 后都可见。

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看见共享变量的最新值以及操作原子性，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

## Volatile 变量

volatile 变量是 Java 语义提供的一种稍弱的同步机制，用来确保将变量的更新通知到其他线程。

当变量被声明为 volatile 时，编译器和运行时采取以下方式：

+ 注意到变量是共享的，禁止变量的操作与其他内存操作一起重排序。
+ 变量不会被缓存到寄存器或者其他处理器不可见的地方。

由于在访问 volatile 变量时是不存在加锁操作也就不会使执行线程阻塞，因此 volatile 变量是一种比 synchronized 关键字更为轻量级的同步机制。[^1]

[^1]: 在当前大多数环境下，读取 volatile 变量只比读取非 volatile 变量的开销略高一些。

volatile 关键字对可见性的影响比 volatile 变量本身更为重要。从内存可见性的角度来看，写入 volatile 变量相对于退出同步代码块，而读取 volatile 变量就相当于进入同步代码块。然而并不建议过度依赖 volatile 变量提供的可见性，因为通常比使用锁的代码更脆弱且难以理解。

> 仅当 volatile 变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性做复杂的判断时，就不要使用 volatile 变量。

volatile 变量的正确使用方式：

+ 确保它们自身状态的可见性。
+ 确保它们所引用对象的状态的可见性。
+ 标识一些重要的程序生命周期事件的发生。

> 注意：volatile 变量只能确保可见性，但不确保操作的原子性。

当且仅当满足以下条件时，才应该使用 volatile 变量：

+ 对变量的写入操作不依赖变量当前的值，或者能确保只有单个线程更新变量的值。
+ 该变量不会与其他状态变量一起纳入不变性条件中。
+ 在访问变量时不需要加锁。