# 使用标准函数接口
#Java 

在 Java 具备 Lambda 表达式特性后，编写 API 的最佳实践也相继发生改变。

原有的[[模版方法模式]]中，用子类实现抽象模版方法来限定父类的行为，这种是最不讨人喜欢的。现在有一种更好的替代方案：方法接收一个函数对象的静态工厂或者构造方法，便可达到同样的效果。

在使用中虽然可以自定义函数接口，但很多时候是不必要的声明，因为 java.util.function 包已经提供了大量标准函数接口。因此，只要标准函数接口能够满足需求，通常应该优先考虑而不是专门再构建一个新的函数接口。

java.util.function 包下有 43 个接口，但只有 6 个基础接口，而其他接口可以由此推出：

| 接口                | 函数签名            | 范例                |
| ------------------- | ------------------- | ------------------- |
| `UnaryOperator<T>`  | T apply(T t)        | String::toLowerCase |
| `BinaryOperator<T>` | T apply(T t1, T t2) | BigInteger::add     |
| `Predicate<T>`      | boolean test(T t)   | Collection::isEmpty |
| `Function<T>`       | R apply(T t)        | Arrays::asList      |
| `Supplier<T>`       | T get()             | Instant::now        |
| `Cusumer<T>`        | void accept(T t)    | System.out::println |

这 6 个基础接口各自还有 3 种变体，分别可以作用于基本类型 int、long 和 double。它们的命名方式是在其基础接口名称前面加上基础类型而得。至此，现有的大多数标准函数接口都只支持基本类型，千万不要带包装类型的基本函数接口来代替基本函数接口。虽然操作可行，但批量自动装拆箱会导致致命的性能问题。

如果需要编写专门的函数接口有两种情况：

1. 提供的标准函数接口中没有合适的。
2. 所需的函数接口具有一项或者多项以下特征，必须考虑自己编写专用的接口。
	+ 通用，并且将受益于描述性的名称。
	+ 具有与其关联的严格的契约。
	+ 将受益与定制的默认方法。

在编写函数接口时，必须始终添加 `@FunctionalInterface` 注解对自己编写的函数接口进行标注，以告知类以及文档的读者，这个接口是针对 Lambda 表达式设计的，同时编译器也保证这个接口只有一个抽象方法。

> ⚠️ 注意：在编写 API 时携带函数接口参数进行多次重载方法时，不要在相同的参数位置上使用不同函数接口，否则会导致客户端歧义。