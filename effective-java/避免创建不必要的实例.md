# 避免创建不必要的实例
#Java 

在可以重用单个实例时，不应该在每次都需要时都创建一个相同功能的新实例。

重用即快速，又流行。如果实例是不可变的，它就始终可以被重用。

例如，一个极端的例子：

```java
String s = new String("bikini");
```

例子中多数创建动作是不必要的，传递的参数本身就是一个 String 实例。如果这类操作在循环中，则会创建大量重复且不必要的实例。同时 JVM 还保证运行的代码中，相同字符串常量会被重用。

当类可以选择静态工厂方法或者构造方法创建实例时，应优先选择静态工厂方法从而避免创建不必要的实例。构造方法在每次调用时都会明确创建一个新的实例，而静态工厂方法则没有这方面的限制。除了重用不可变的实例之外，也可以重用那些已知不会被修改的实例。

## 缓存创建成本高实例

如果实例的创建成本相较于其他实例较高且需要重复使用时，就应该缓存起来。

例如，String.matches 方法需要重复创建 Pattern 实例，而 Pattern 实例的创建成本很高：

```java
private static final Pattern REGIX = Parttern.complie(...);

public static final boolean isRoman(String s) {
	return REGIX.matcher(s).matches();
}
```

## 无需重复创建视图实例

如果实例是不可变的，那么它显然可以被安全的重用，但是部分其他情况则表现的不总是那么明显。考虑到[[适配器模式]]的情形，有时也称作视图。

例如，Map 实例在每次调用 keySet 方法时，实际上每次调用都返回相同的 Set 实例。虽然被返回的 Set 实例可以被改变，但是返回实例在功能上是等同的：当其中一个返回实例发生变化时，所有其他实例都会发生变化，因为它们是由同一个 Map 实例支撑的。

> 创建多个视图实例虽然没有害处，但却是没有必要的，也没有任何好处。

## 避免过多使用自动装箱

自动装箱也是一种创建多余实例的方式，它允许程序员将基本类型和装箱类型混用，按需要自动装箱和拆箱。

虽然自动装箱使基本类型与包装类型之间的界限变得模糊，但是并没有完全消除。因为它们在语义和性能上有着较为明显的差别。

例如，数字累加：

```java
private static long sum() {
	Long sum = 0L;
	for (long i = 0; i <= Integer.MAX_VALUE; i++) {
		sum += i;
	}
	return sum;
}
```

例子中的 sum 变量使用 Long 类型声明，这意味着循环过程中会创建许多不必要的 Long 类型实例，这对程序的性能有着较大的影响。因此，要优先使用基本类型而不是包装类型，要当心无意识的自动装箱。

## 避免维护实例池

手动维护自己的实例池来避免重复创建实例并不是一种好的做法，除非池中的实例是非常重量级的。例如，正确使用实例池的典型就是数据库连接池。因为数据库连接的代价是非常昂贵的，因此重用非常有意义。而且，数据库的许可可以限制一定数量的连接。

但是一般而言，维护自己的实例池必定会把代码弄得很乱，同时增加内存占用，并且还会损坏性能。现代 JVM 实现具有高度优化的垃圾回收器，其性能很容易就会超过轻量级对象池的性能。