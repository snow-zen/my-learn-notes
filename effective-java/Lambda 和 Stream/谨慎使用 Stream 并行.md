# 谨慎使用 Stream 并行
#Java 

在主流的编程语言中，Java 一直走在简化并发编程任务的最前沿。在 Java 8 引入 Stream 后只需要调用一次 parallel 方法就可以实现并行处理。在 Java 中编写并行程序变得越来越容易，但是编写出正确又快速的并发程序，则一向没有这么简单。安全性和活跃性失败是并发编程中需要面对的问题，Stream pipeline 并行也不例外。

如果源 Stream 是来自于 Stream.iterate 或者使用了中间操作的 limit，那么并行 pipeline 是不可能提升性能。默认的并行策略在处理 limit 的不可预知性时，是假设额外多处理几个元素，并放弃任何不需要的结果，这会造成额外的性能浪费。

> 千万不要任意地并行 Stream pipeline。它造成的性能后果有可能是灾难性的。

总之，在 Stream 上通过并行获得的性能，最好是通过 ArrayList、HashMap、HashSet 和 ConcurrentHashMap 实例，数组，int 范围和 long 范围等。这些数据结构存在以下共性：

+ Stream 和 Iterable 可通过 spliterator 分割迭代器把它们精确、轻松地分成任意大小的子范围，使并行线程中的分工变得更加轻松。
+ 在顺序处理时，它们提供了优异的**引用局部性**：序列化的元素引用一起保存在内存中。

Stream pipeline 的终止操作本质上也会影响并发执行的效率。如果大量的工作在终止操作中完成，而不是全部工作在 pipeline 中完成，并且这个操作还是固有顺序，则并行的效率会受限制。并行的最佳操作是做减法，例如：

1. 使用 reduce 方法将所有从 pipeline 产生的元素都合并在一起。
2. 预先打包像 min、max、count 和 sum 这类方法。**骤死式操作**如 anyMatch、allMatch 和 noneMatch 也都可以并行。

> 由 Stream 的 collect 方法执行的操作都是可变的减法，不是并行的最佳选择，因为合并集合的成本很高。

并行 Stream 不仅可能降低性能，包括活跃性失败，还可能导致结果出错，以及难以预计的行为。安全性失败的可能在于并行的 pipeline 使用了映射、过滤器或者程序员自己编写的其他函数对象，并且没有遵守它们的规范。并行 Stream 是一项严格的性能优化。对于任何优化都必须在改变前后对性能进行测试，以确保值得这么做。最理想的是在现实的系统设置中进行测试。

一般来说，程序中所有的并行 Stream pipeline 都是在一个通用的 fork-join 池中运行的。只要有一个 pipeline 运行异常，都会损害到系统中其他不相关部分的性能。听起来貌似在并行 Stream pipeline 时怪事连连，其实正是如此。但这并不意味着应该避免使用并行 Stream，在适当的条件下，给 Stream pipeline 添加 parallel 调用，确实可以在多处理器核心的情况下实现近乎线性的倍增。例如，机器学习和数据处理中，尤其适用于这样的提速。