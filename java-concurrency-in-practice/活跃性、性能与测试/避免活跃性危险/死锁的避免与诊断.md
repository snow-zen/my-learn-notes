# 死锁的避免与诊断
#Java #Multithreading 

如果某个功能必须获取多个锁，那么在设计时必须考虑锁的顺序。同时也应该尽量减少潜在的加锁交互数量，将获取锁时需要遵循的协议写入正式文档并始终遵循这些协议。

在使用细粒度锁的程序中，可以通过一种两阶段策略来检查代码中的死锁：

1. 找出在什么地方获得多个锁。
2. 对所有这些实例进行全局分析，确保它们在整个程序中获取锁的顺序都保持一致。
3. 尽可能使用开放调用，可极大简化分析过程。

如果所有调用都是开放调用，那么要发现获取多个锁的实例变得非常简单，可以通过代码审查，或者借助自动化的源代码分析工具。

## 通过支持定时的锁来避免死锁

显式使用 Lock 类中的定时 tryLock 方法来代替内置锁机制。不同于内置锁对锁的无线等待， tryLock 方法可以指定一个超时时间，超过时间后返回一个失败信息。而获得失败信息后，我们无需关心失败的原因，而且可以记录失败的原因以及其他操作信息后重新进行计算，而不是直接关闭整个进程。

## 通过线程转储信息来分析死锁

JVM 可以通过线程转储（Thread Dump）来帮助识别死锁的发生。线程转储中包含以下信息：

+ 加锁信息。
+ 锁的持有线程。
+ 获得锁的栈帧。
+ 被阻塞的线程正在获得的锁。

在生成线程转储之前，JVM 将在等待关系图中通过搜索循环来找出死锁。发现死锁则获取相应的死锁信息。

触发线程转储操作：

+ UNIX 按下 `Ctrl + /` 键。
+ Windows 按下 `Ctrl + Break` 键。

线程转储的锁信息开始只包含对内置锁的支持，JDK 6 后包含对显式 Lock 的线程转储和死锁检测等支持，但相比内置锁获得的信息精确度低，只能获取它关联的线程。