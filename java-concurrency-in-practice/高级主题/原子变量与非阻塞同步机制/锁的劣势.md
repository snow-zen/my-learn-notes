# 锁的劣势
#Java #Multithreading 

通过一致性的锁定协议来协调对共享状态的访问，可以确保无论哪个线程都是以独占的方式持有锁来进行访问，修改后的共享状态对随后的持有锁的其他线程都是可见的。

现代的许多 JVM 对非竞争锁获取和锁释放都做了极大的优化，但如果有多个线程同时请求锁，那么 JVM 就需要借助操作系统的功能。在锁上发生竞争时，智能 JVM 会根据之前持有锁的时间长短来判断此线程是挂起还是自旋等待。如果出现了这种情况，那么一些线程将被挂起并且在稍后恢复运行。当线程恢复时，必须等待其他线程执行完他们的时间片后，才能被调度使用。在挂起和恢复线程的过程中存在很大的开销，并且通常存在较长时间的中断。如果当锁上存在激烈的竞争时，调度开销与工作开销的比值会非常高。

虽然与锁相比，volatile 类型变量是一种更轻量的同步机制，因为使用这种变量时不会发生上下文的切换或线程调度等操作。但 volatile 类型变量有着明显的局限性：它们只能提供变量的可见性保证，但不能构建原子的复合操作。因此，当一个变量依赖其他的变量时，或者当变量的新值依赖旧值时，就不能使用 volatile 变量。

锁还存在其他一些缺点。当一个线程在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的时候被延迟执行（例如发生缺页错误、调度延迟或者其他类似情况），那么所有需要这个锁的线程都会无法执行下去。另外如果持有锁的线程是低优先级，而被阻塞的其他线程中存在高优先级，那么这将是一个严重的问题 —— 也被称为**优先级反转**。