# 覆盖 equals 方法时始终要覆盖 hashCode 方法
#Java 

在每个覆盖 equals 方法的类中，都必须要覆盖 hashCode 方法。如果不这样做，就违反了 hashCode 通用约定，从而导致该类无法结合所有基于散列值的集合一起工作。

Object 中存在以下规范：
1. 程序运行期间，只要实例的 equals 方法所用到的关键属性没有更改，在同一实例上调用 hashCode 方法始终返回同一个值。
2. 如果两个实例调用 equals 方法是相等的，则调用两个实例的 hashCode 都必须产生相同的结果。
3. 如果两个实例根据 equals 方法比较是不相等的，则调用这两个实例的 hashCode 方法时，无需产生不一样的结果。

> 虽然 Object 不要求不同的实例调用 hashCode 方法必须返回不同的值，但程序员需要知道尽可能产生不同值的散列函数可以提升性能。

在覆盖 equals 方法时没有覆盖 hashCode 方法时，会违反第 2 条规范。在 HashMap 等依赖散列值的容器中，调用 get 方法会无法获取实例，即使两个实例在逻辑上是相等的。

## 提供优秀的 hashCode 方向

覆盖 hashCode 方法虽然可以解决 HashMap 中，在插入键值对后使用同一键调用 get 方法为 null 的问题，但是设计粗糙的散列函数会增加任务的运行时间。

例如，糟糕的散列函数：

```java
@Override
public int hashCode() {
	return 42;
}
```

例子中的 hashCode 方法虽然合法，也确保相同的对象具有相同的散列值，但也使得每个对象的散列值是相同的。在使用 HashMap 容器时，所有元素都映射到同一个散列通中，会使得 HashMap 退化成一个链表，本该线性时间运行的程序变为平方级时间运行。

## 编写 hashCode 方法诀窍

好的散列函数通常倾向于“为不同的对象生成不相等的散列值”。理想状态下，散列函数应该把集合中不相等实例均匀地分布到所有可能的 int 值上，但想完全达到理想的情形是非常困难的。但幸运的是，相对接近这种理想情形并不困难。

通过简单的方式编写散列函数：
1. 声明一个 int 类型变量 result，初始化值为实例第一个关键属性的散列值。
2. 实例中剩余关键属性都通过以下步骤处理：
	1. 计算该关键属性的散列值：
		+ 当属性为基本类型时，通过 *Type*.hashCode 方法计算散列值，Type 为基本类型对应的包装类型。
		+ 当属性为引用类型时，可递归调用属性的 hashCode 方法。如果过程中需要更复杂的比较，则可为属性计算一个“范式”，然后针对范式调用 hashCode。当属性值为 null 时，返回 0。
		+ 当属性为数组类型时，需要把每个元素当作单独的属性来处理。递归的应用上述规则计算散列值，之后通过 2.2 步骤将散列值合并起来。如果数组中所有元素都重要，可以使用 Array.hashCode 方法进行统一计算。
	2. 通过 `result = 31 * result + hashCode` 表达式将散列值合并。
3. 返回 result 值。

> 在计算散列值的过程中可以把衍生属性排除在外。

在 2.2 步骤下使用一个奇素数常量 31 进行计算，存在以下好处：当乘数是偶数并且乘法溢出时，信息会丢失，因为与 2 相乘等价于移位操作。31 有个很好的特性是，可以利用移位和减法来代替乘法，并且可以获得更好的性能。

大多数情况下，大多数实例使用简单的方式就已经足够了。Object.hashCode 方法实现往往非常快，但是对于 hash 冲突的预防能力较弱。在常规的 HashMap 使用时，使用 Object.hashCode 是足够的，但是对于除此之外的用途中，它几乎总是达不到要求，此时我们可以使用 `com.google.common.hash` 代替。

如果类是不可变的情况下，并且计算散列值开销较大时，可以考虑把散列值缓存在对象内部。如果认为对象的散列值一定会被使用到时，可以在创建实例时就计算。否则，可以选择延迟初始化散列值：

```java
private int hashCode;

@Override
public int hashCode() {
	int result = hashCode;
	if (result == 0) {
		// generate hash code ...
	}
	return result;
}
```

## 使用 hashCode 注意事项

1. 不要试图从散列值计算中排除一个对象的关键属性来提高性能。因为排除属性在实例可能存在非常大的区别，排除可能导致原本不同的实例映射到极少数的散列值中，这可能导致依赖散列值容器的运行时间从线性下降到平方级。
2. 不要对 hashCode 方法的返回值做出具体的规定，因为客户端无法理所应当地依赖。