# 读 - 写锁
#Java #Multithreading 

ReentrantLock 实现了一种标准的互斥锁：每次最多只有一个线程持有锁。对于维护数据的完整性来说，互斥通常是一种过于强硬的加锁规则，因此也就不必要地限制了并发性。

互斥是一种保守的加锁策略，虽然可以避免“写/写”冲突和“写/读”冲突，但同样也避免了“读/读”冲突。在许多情况下大多数访问操作都是“读操作”，如果能够放宽加锁需求，允许多个执行读操作的线程同时访问数据结构，那么将提升程序的性能。

读 - 写锁：一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。

Java 提供了 ReadWriteLock 接口用于指定加锁，接口如下：

```java
public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}
```

读-写锁是一种优化策略，在一些特定情况下可以实现更高的并发性。在实际情况中，对于在多处理器系统上被频繁读取的数据结构，读-写锁能够提高性能。而在其他情况下，读-写锁的性能比独占锁的性能要略差一些，这是因为它们的复杂性更高。

> 因此如果要判断在某种情况下使用读-写锁是否会带来性能提升，最好对程序进行分析。

## ReentrantReadWriteLock

ReentrantLock 的实现，同时为两种锁都提供了可重入的加锁语义。如果这个锁由读线程持有，而另一个线程请求写入锁，那么其他线程都不能获得读取锁，直到写线程使用完并且释放了写入锁。

在非公平的锁中，线程获得访问许可的顺序是不确定的。写线程降级为读线程是可以的，但从读线程升级为写线程是不可以的。因为如果两个线程试图同时升级为写入锁，那么二者都不会释放读取锁，则造成死锁。

在 Java 5.0 中，读取锁的行为更类似于一个 Semaphore 而不是锁，它只维护活跃的读线程的数量，而不考虑它们的标识。在 Java 6.0 中修改了这个行为：记录哪些线程已经获得了读取锁。修改的原因是：Java 5.0 的锁实现中，无法区别一个线程是首次请求读取锁，还是可重入请求，从而可能使公平的读-写锁发生死锁。

当锁的持有时间较长并且大部分操作都不会修改被守护的资源时，那么读-写锁能提高并发性。