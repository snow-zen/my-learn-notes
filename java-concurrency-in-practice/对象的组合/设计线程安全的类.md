# 设计线程安全的类
#Java #Multithreading 

与将程序的所有状态都保存到公有静态域相比，通过封装可以在不对整个程序进行分析的情况下即可判断一个类是否线程安全。

设计线程安全类的过程中，需要包含以下三个基本要素：

+ 找出构成对象状态的所有变量。
+ 找出约束状态变量的不变性条件。
+ 建立对象状态的并发访问管理策略。

同步策略定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略还规定如何将不可变性、线程封闭性与加锁等特性结合起来维护线程的安全性，并且还规定了哪些变量由哪些锁保护。

同步策略由于客观存在复杂性，需要将同步策略写为正式文档，确保开发人员可以对这个类进行分析与维护。

## 收集同步需求

确保类的线程安全性，就是要确保它的不变性条件不会在并发访问的情况遭到破坏，而这需要对对象的状态进行推断。

**状态空间**

对象和变量都有一个状态空间，即所有可能状态的值。状态空间越小，就越容易判断线程的状态。而使用 final 类型域的优点就在于限制其状态空间，使用 final 类型域越多就越能简化对象可能的状态的分析过程。

**后验条件**

在操作上，存在一些后验条件判断当前状态是否有效。例如自增操作的下一状态依赖于上一状态的值，因此状态的可能值也会被进一步限制。

**不变性条件**

如果某些状态是无效的，就需要对底层的状态变量进行封装，防止客户端代码将状态变为无效。如果某些复合操作中存在无效状态的中间状态，那么就需要保证复合操作是原子性的。另外，如果类中没有施加这些约束，那么可以放宽封装性和序列化等需求。以便获得更高的灵活性与性能。

>类中也可以包含同时约束多个状态变量的不变性条件。这种包含多个变量的不变性条件将带来原子性需求：这些相关的变量必须在单个原子操作中进行读取和更新。

如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量操作时，都必须持有这些变量的锁。

> 注意：如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换的各种约束条件，就需要借助于原子性与封装性。

## 依赖状态的操作

类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。

在某些对象的方法中还包含一些基于状态的先验条件。如果某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。

在单线程操作中，如果先验条件无法满足则程序只能失败。而并发程序中即使此刻先验条件无法满足但其他线程的操作可能使得先验条件得到满足，因此并发程序中可以等到先验条件为真再执行操作。

## 状态的所有权

在定义哪些变量构成对象的状态时，只考虑对象拥有的数据。所有权在 Java 中并没有得到充分的体现，而是属于类设计的一个要素。因为在 Java 中垃圾回收机制使我们避免了如何处理所有权的问题。

在 C++ 中，当把一个对象传递给某个方法时，必须认真考虑这种操作是否传递对象的所有权，是短期的所有权还是长期的所有权。在 Java 中同样存在所有权模型，只不过垃圾回收机制为我们避免了引用共享方面的常见错误，因此降低了在所有权处理上的开销。

许多情况下，所有权与封装性总是相互关联的：对象封装它拥有的状态，反之也成立，即对它封装的状态拥有所有权。状态变量的拥有者可采用加锁协议来维持变量的完整性，所有权就意味着控制权。如果某个可变的对象引用被发布，那么就不再拥有独占的控制权，最多是“共享控制权”。对于从构造函数或方法中传入的对象，类通常不拥有这些对象，除非这些对象是专门设计为转移进来的对象的所有权。

容器类通常表现为“所有权分离”的形式，其中容器拥有自身的状态，而客户端代码拥有容器中各个对象的状态。Spring 中的 BeanFactory 就是其中一个示例，BeanFactory 是线程安全的，我们在注册和获取 Bean 时不需要额外的同步。但是我们使用注册到 BeanFactory 中的 Bean 时是需要同步的，因为这些 Bean 对象被所有线程共享，为了防止多个线程在并发访问同一个对象时产生相互干扰，这些对象应该是线程安全的对象，要么是事实不可变的对象，或者由锁来保护的对象。