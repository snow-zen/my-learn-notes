# 谨慎地实现 Serializable 接口
#Java 

很多人认为实现 Java 序列化只需要实现 Serializable 接口即可，非常容易。但实际上情形要复杂的多，序列化所付出的长期开销往往是相当高的。

实现 Serializable 接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类实现”的灵活性。因为类序列化的字节编码也可以算导出 API 的一部分，一旦被广泛使用则后续必须进行支持。

> 实现序列化时，必须要给类添加一个私有静态 final 的 long 类型属性 serialVersionUID 作为唯一标识符。同时不要修改该属性值，否则将会破坏类现有的已被序列化实例的兼容性。

实现 Serializable 接口的第二个代价是，增加了出现 Bugs 和安全漏洞的可能性。由于反序列化是一种隐藏的构造方法，它也必须在构造对象时维护对象内部的约束关系。默认的反序列化机制很容易破坏约束关系以及进行非法访问。

实现 Serializable 接口的第三个代价是，随着类发行新版，相关的测试负担也会增加。当一个可序列化的类被修订时，需要测试各个版本之间的序列化和反序列化是否正常。

实现 Serializable 接口并不是一个很轻松就可以做出的决定。实现该接口会带来许多的性能开销，需要权衡所付出的代价和带来的好处。尤其是为了继承而设计的类应尽可能的少去实现 Serializable 接口，用户的接口也应该尽可能少继承 Serializable 接口，否则扩展该接口的程序员就会背上沉重的压力。

> 内部类不应该实现 Serializable 接口。