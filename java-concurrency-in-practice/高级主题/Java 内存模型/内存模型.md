# 内存模型
#Java #Multithreading 

内存模块用于保证一个线程可以看到另一个线程对共享变量的变更结果。

内存模型所面临的问题：

+ 编译器内生成的指令顺序可以与源代码中的顺序不同。
+ 编译器还会把变量保存到寄存器而不是内存中。
+ 处理器可以采用乱序或并行等方式来执行指令。
+ 缓存可能会改变将写入变量提交到主内存的次序。
+ 保存在处理器本地缓存中的值，对于其他处理器是不可见的。

在没有使用同步机制的情况下，这些因素都可能导致一个线程无法看到变量的最新值，且会导致其他线程中的内存操作似乎是乱序。

Java 语言规范要求 JVM 在线程中维护一种类似串行的语义：只要程序的最终结果与在严格串行环境中执行的结果相同，那么上述所有操作都是允许的。在多线程环境中，维护程序的串行性将导致很大的开销。

大部分时间里线程都是执行各自的任务，因此多个线程协调操作时只会降低应用程序的运行速度。只有当多个线程要共享数据时，才必须协调它们之间的操作，并且 JVM 依赖程序通过同步操作来找出这些协调操作将在何时发生。

JMM 规定了 JVM 必须遵守一组最小保证，这组保证规定了对变量的写入操作在何时对于其他线程可见。

## 平台的内存模型

在不同的处理器架构中提供了不同级别的缓存一致性，其中一部分只提供最小的保证，即允许不同的处理器在任意时刻从同一个存储位置上看到不同的值。

要想确保每个处理器都能在任意时刻知道其他处理器正在进行的工作，将需要非常大的开销。操作系统、编译器以及运行时甚至是应用程序都需要弥合这种在硬件能力与线程安全需求之间的差异。在架构定义的内存模型中将告诉应用程序可以从内存系统中获得怎样的保证，此外还定义了一些特殊的指令（称为内存栅栏），当需要共享数据时，这些指令就能实现额外的存储协调保证。

为了使 Java 开发人员无须关心不同架构上内存模型之间的差异，Java 还提供了自己的内存模型，并且 JVM 通过在适当的位置上插入内存栅栏来屏蔽在 JMM 与底层平台内存模型之间的差异。

程序执行存在一种简单的假设：想象在程序中只存在唯一的操作顺序，而不考虑这些操作在何种处理器上执行，并且在每次读取变量时，都能获得在执行序列中最近一次写入该变量的值。这种乐观的模型就被称为串行一致性。

> 软件开发人员经常会错误的假设存在串行一致性，但在任何一款现代多处理器架构中都不会提供这种串行一致性，JMM 也是如此。

## 重排序

在没有同步的情况下，由于调度器采用交替执行不同的线程操作会使操作延迟或者看似乱序执行的不同原因都可以归为重排序。在缺少同步的程序中，重排序会导致列举它所有可能的执行结果非常困难。

同步将限制编译器、运行时和硬件对内存操作重排序的方式，从而实施重排序时不会破坏 JMM 提供的可见性保证。

在大多数主流的处理器架构中，内存模型都非常强大，使得读取 volatile 类型变量和读取普通变量的性能大致相当。

## 内存模型

Java 内存模型是通过对变量的读/写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。

JMM 为程序中所有的操作定义了一个偏序关系，称为 Happens-Before。要想保证执行操作B的线程看到操作 A 的结果（无论 A 和 B 是否在同一个线程中执行），那么在 A 和 B 之间必须满足 Happens-Before 关系。

如果两个操作之间缺乏 Happens-Before 关系，那么 JVM 可以对它们任意地重排序。当一个变量被多个线程读取并且至少被一个线程写入时，如果在读取操作和写入操作之间没有依照 Happens-Before 来排序，那么就会产生数据竞争关系。

在正确同步的程序中不存在数据竞争，并会表现出串行一致性，这意味着程序中的所有操作都会按照一种固定的和全局的顺序执行。

Happens-Before 规则包括：

+ **程序顺序规则**。如果程序中操作 A 在操作 B 之前，那么在线程中 A 操作将在操作 B 之前执行。
+ **监视器锁规则**。在监视器锁上的解锁操作必须在同一个监视器锁上的加锁操作之前执行。

> 显式锁和内置锁在加锁和解锁等操作上有着相同的内存语义。

+ **volatile 变量规则**。对 volatile 变量的写入操作必须在对该变量的读操作之前执行。

> 原子变量与 volatile 变量在读操作和写操作上有着相同的语义。

+ **线程启动规则**。在线程上对 Thread.start 方法的调用必须在该线程中执行任何操作之前执行。
+ **线程结束规则**。线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从 Thread.join 方法中返回，或者调用 Thread.isAlive 方法时返回 false。
+ **中断规则**。当一个线程在另一个线程上调用 interrupt 方法时，必须在被中断线程检测到 interrupt 方法调用之前执行（通过抛出 InterruptedException 或者调用 isInterrupted 和 interrupted 方法）。
+ **终结器规则**。对象的构造函数必须在启动该对象的终结器之前执行。
+ **传递性规则**。如果操作 A 在操作 B 之前执行，操作 B 在操作 C 之前执行，那么操作 A 必须在操作 C 之前执行。

## 借助同步

由于 Happens-Before 的排序功能很强大，因此有时候可以“借助”现有同步机制的可见性需求。这需要将 Happens-Before 的程序顺序规则与其他某个顺序规则（通常是监视器锁排序或者 volatile 变量规则）结合起来，从而对某个未被锁保护的变量的访问操作进行排序。

这项技术由于对语句的顺序非常敏感，因此很容易出错。因此它是一项高级技术，并且只有当需要最大限度地提升某些类的性能时，才应该使用这项技术。

例如，说明如果借助同步的 FutureTask 的内部类：

```java
private final class Sync extends AbstractQueuedSynchronizer {
    private static final int RUNNING = 1, RAN = 2, CANCELLED = 4;
    private V result;
    private Exception exception;

    void innerSet(V v) {
        while (true) {
            int s = getState();
            if (ranOrCancelled(s)) {
                return;
            }
            if (compareAndSetState(s, RAN)) {
                break;
            }
        }
        result = v;
        releaseShared(0); // 写入volatile变量操作
        done();
    }

    V innerGet() throws InterruptedException, ExecutionException {
        acquireSharedInterruptibly(0); // 读取volatile变量操作
        if (getState() == CANCELLED) {
            throw new CancellationException();
        }
        if (exception != null) {
            throw new ExecutionException(exception);
        }
        return result;
    }
}
```