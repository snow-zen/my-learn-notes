# 集成测试
#UnitTest 

任何测试，如果它运行速度不快，结果不稳定，或者要用到被测试单元的一个或多个真实依赖物，则可以被认为是集成测试。例如，一个测试要用到真实的时间、真实的文件系统或者真实的数据库，那这个测试就进入了集成测试的领域。

这种测试本身并不是坏事，集成测试和单元测试具有同等重要的地位，但是这两种测试应该彼此分开，以营造一种“绿色安全区”的感觉。集成测试还可能带来另外一个问题：一次测试的东西太多了，无法准确定位问题所在。

集成测试的定义：

> 集成测试是对一个工作单元进行的测试，这个测试对被测试的工作单元没有完全控制，并使用该单元的一个或多个真实依赖物，例如时间、网络、数据库、线程或者随机数产生器。

总之，集成测试会使用真实依赖物，而单元测试则把被测试单元和其依赖物隔离开，以保证单元测试结果高度稳定，还可以轻易控制和模拟被测试单元行为的任何方面。

## 与自动化单元测试相比，非自动化集成测试的缺点

我们将把[[优秀单元测试的特性]]中所提出的问题应用在集成测试上，思考使用单元测试的目的。

**两周前写的一个单元测试，今天还能运行吗？几个月前呢？几年前写的呢？**

如果回答是“不能”，则无法保证自己是不是已经破坏了以前实现的某个功能？在应用程序的生命周期中，代码经常发生变化。如果在修改代码后，无法对之前所有的功能进行测试，就有可能破坏了某个功能而毫不知情。这种情况称为“偶然引入缺陷”。

“偶然引入缺陷”在修改代码时经常发生，优秀的单元测试可以在破坏功能后三分钟内就能发现问题。

> 回归定义：以前运行良好但是现在不工作的一个或多个工作单元。

**两个月前写的单元测试，团队任何一个人都能运行它们并得到结果吗？**

当你做改动时，需要保证自己不会破坏别人的代码。许多开发人员都害怕修改以前系统中的遗留代码，就是担心不知道有什么别的代码依赖他们要改动的部分。简而言之，他们不知道系统修改后的状态是否稳定。

应用程序是否能够正常工作是很令人担忧的，尤其代码还不是自己写的。如果知道自己不会破坏任何功能，则比较有信心接手不太熟悉的代码，因为单元测试这个安全网，优秀的单元测试可被任何人访问和运行。

> 遗留代码定义：没有测试的代码。

**能在几分钟内跑完我写过的所有单元测试吗？**

如果不能很快的运行完测试，就不会经常运行它们。问题是，如果修改代码，则需要尽早得到反馈。运行测试的时间间隔越长，对系统做未测试的修改越多，出现问题的时候需要找寻缺陷的地方就越多。

优秀的测试需要能够快速运行。

**能一键运行我写过的所有单元测试吗？**

如果不能，那可能意味着你需要对运行测试的机器进行配置，让测试能够正确运行，或者单元测试不是完全自动化的。

如果不能完全自动化单元测试，则可能回避免重复运行这些测试，团队里的其他人也一样。没有人喜欢费功夫配置然后运行测试，而结果只是为了保证系统还能运行。

优秀的测试应该无需修改就能运行，不需要手工配置。

**能在几分钟内写出一个基本的测试吗？**

辨别集成测试的一个最简单办法就是：集成测试需要花时间进行正确的准备和实施，不能直接执行。如果不对测试进行自动化，依赖就不是什么大问题，但也会失去享受自动化测试所带来好处的机会。

编写测试的难度越高，编写更多测试的可能性就越小，对所担心的“大问题”之外的东西的关注度就会减少。单元测试的一个特点就是会测试可能出问题的每一处细节，而不只是关注大问题。

> 人们常常惊讶：有很多缺陷正是在认为简单的代码中找到的。

当你只关注大的测试时，测试的逻辑覆盖率就会比较低，代码中的核心逻辑的很多部分不会测到，这样就可能会出现没有考虑到的缺陷。

一旦找到想用来测试具体对象模型的模式，就应该可以轻松编写出优秀的测试。但有一个小小的警告：对一个以前没有做过单元测试的对象模型，即便是有经验的单元测试人员，也需要花 30 分钟或者更长的时间才能写出第一个单元测试。这种摸索工作是难免的，也是预料之中的。对这个对象模型的第二个以及之后的测试应该很容易完成。