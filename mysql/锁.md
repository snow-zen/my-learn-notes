# 锁
#MySQL 

无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。

## 读写锁

在处理并发读或写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁和排他锁，也称读锁和写锁。

读锁是共享的，多个读锁之间共享同一资源。写锁是排他的，就是说一个写锁会阻塞其他的写锁和读锁。

写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面。

## 锁粒度

提高共享资源并发性的一种方式方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。

理想状况下，只对需要修改的数据片进行精确的锁定。任何情况下，在给定资源上，锁定数据越少，系统并发程度越高。问题是加锁也需要消耗资源。锁的各种操作，例如获取锁、检查锁是否已解除、释放锁等，都会增加系统的开销。

> 所谓锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。

MySQL 中锁策略和锁粒度是由存储引擎实现的，可通过替换存储引擎来选择多种解决方案。

**表锁**

表锁是 MySQL 中最基本的锁策略，并且是开销最小的策略。

尽管存储引擎可以管理自己的锁，MySQL 本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器为 `ALTER TABLE` 之类的语句使用表锁，而忽略存储引擎的锁机制。

**页锁**

页锁是 MySQL 中比较独特的一种锁定级别。页级锁的粒度介于行锁和表锁之间，因此所需要的资源开销以及所能提升的并发处理能力同样也是介于两者之间。

**行锁**

行锁的粒度在 MySQL 中最小，也是最大程度支持并发处理。行锁由存储引擎实现，但是只有部分存储引擎实现了行锁，例如 InnoDB。



