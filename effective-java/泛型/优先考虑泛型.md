# 优先考虑泛型
#Java 

一般来说，将集合声明为参数化，以及使用 JDK 所提供的泛型方法，这些都不会太困难。编写自己的泛型会比较困难一些，但是值得花些时间去学习如何编写。

以集合为例，对于集合内部真正存储的数组属性，有两种表达方式。

首先，第一种方式使用 `E[]` 表示，数组直接声明为泛型数组。但是在初始化时是无法直接创建出具体化的数组：

```java
E[] arr = new E[DEFAULT_INITIAL_CAPACITY]; // 报错
```

正如[[列表优于数组#泛型数组非法]]中所诉，你不能创建不可具体化的类型数组。解决办法是创建一个 `Object[]` 类型数组后强转为 `E[]` 类型，此时编译器不会报错但产生警告。这种用法虽然是合法的，但是整体上不是类型安全的：

```java
@SuppressWarning("unchecked")
E[] arr = (E[]) new Object[];
```

编译器无法证明程序是安全的，但是你可以。你必须确保未受检转换不会危及程序的类型安全性：相关的数组保存在一个私有属性中，永远不会被返回到客户端，或者传给任何其他方法。这个数组中保存的唯一元素，是传给 push 方法的那些元素，它们的类型为 `E`，因此未受检转换不会有任何危害。

一旦你证明了未受检转换是安全的，就要在尽可能小的范围中禁止警告。[^1] 

[^1]: [[消除非受检异常]]

其次，第二种方式是使用 `Object[]` 类型表示，在访问操作中进行转换。转换时，由于泛型是不可具体化类型，因此编译器也是会产生一条警告：

```java
public E pop() {
	if (size == 0) {
		throw new EmptyStackException();
	}
	
	@SuppressWarning("unchecked")
	E result = (E) elements[--size];
	elements[size] = null;
	return result;
}
```

这两种消除泛型数组创建的方法，各有所长。第一种方法可读性更强，数组被清楚的声明为具体泛型，且只需要在创建数组时进行一次类型转换即可，但它会导致堆污染，数组的运行时类型与它的编译时类型不匹配。第二种每次读取元素都要进行一次转换，没有堆污染。这使得有些程序员会觉得很不舒服，因而选择第二种方案，虽然堆污染在这种情况下并没有什么危害。

Java 泛型系统还存在一个基本局限性，无法将普通类型指定为泛型类型，但可以使用它们的基本包装类型。另外，泛型还可以通过有限制的类型参数来限制可允许的类型参数值：

```java
class Example<E extends Object> {}
```

此时泛型只能为 Object 类型或它的子类型，此时泛型 E 被称作**有限制的类型参数**。