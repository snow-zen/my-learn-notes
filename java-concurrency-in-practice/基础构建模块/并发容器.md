# 并发容器
#Java #Multithreading 

JDK 5 提供了多种并发容器类来改进同步容器的性能。

同步容器会将所有对容器状态的访问都串行化，以实现它们的线程安全性。这种方式会严重降低程序的并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。而并发容器是针对同步容器专门设计的，通过并发容器来替代同步容器，可以极大地提高伸缩性并降低风险。

并发容器的代替关系：

+ ConcurrentHashMap 代替同步 Map
+ CopyOnWriteArrayList 代替同步 List

在新的 ConcurrentHashMap 中增加了一些常见的复合操作支持。例如：若不存在则添加、替换以及有条件的删除功能。

另外 JDK 5 中也增加了两种新的容器类型：Queue 和 BlockingQueue。Queue 是一种先进先出（FIFO）的数据结构 —— 队列，它可用来临时存储一组等待处理的元素，Queue 上的操作不会阻塞，当队列为空时获取操作将返回空值。Queue 提供以下几种实现：

+ ConcurrentLinkedQueue：传统意义上的先进先出并发队列。
+ PriorityQueue：非并发的优先队列。

Queue 接口继承于 List 接口，提供了队列的操作，同时底层使用 LinkedList 来实现 Queue，从而实现更高效的并发。

BlockingQueue扩展了Queue接口，添加了可阻塞的插入和获取操作。在队列为空时，获取操作会阻塞到有新的元素加入队列；同时在队列已满时，插入操作会阻塞到队列中出现可用空间。

## ConcurrentHashMap

同步容器类在执行每个操作期间都持有一个锁。但部分操作存在包含大量工作，例如 Map 的 get 操作、List 的 contains 操作。当遍历散列桶或链表来查找某个特定的对象，必须在多个对象上调用 equals。在基于散列的容器中，如果散列函数很糟糕还会把散列表退化线性列表。在遍历很长的列表中调用部分或全部元素的 equals 方法会花费很长的时间。

ConcurrentHashMap 采用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为**锁分段**。该机制下，执行读取操作和写入操作的线程可以并发的访问 Map，且一定数量的写入线程可以并发修改 Map。ConcurrentHashMap 在并发访问环境下将实现更高的吞吐量，且单线程环境中只损失非常小的性能。

与其他并发容器相同，它们提供的迭代器不会抛出 ConcurrentModificationException 异常，因此不需要在迭代过程中对容器加锁。因为提供的迭代器具有弱一致性，而并非“及时失败”。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以在迭代器构造后修改操作可反映到容器。

> ⚠️ 注意：尽管有这些优化，但仍然有一些需要权衡的因素。对于某些需要整个 Map 进行计算的方法，例如 size 方法或 isEmpty 方法将被略微减弱以保证容器的并发性。由于 size 方法返回的结果本身在并发常见下本身并不准确，因此这方面的需求会被弱化。

由于 ConcurrentHashMap 并没有实现对 Map 的独占式加锁，因此在一些需要原子方式添加映射，或者对 Map 迭代若干次并在此期间保持元素顺序的场景下可能不太适用。

## CopyOnWriteArrayList

CopyOnWriteArrayList 用于代替同步 List，在某些场景下它可以提供更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。

类在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。在创建迭代器时，也会创建一个容器副本作为迭代快照，由于数组快照不会被其他线程修改，因此在对其进行同步时只需确保数组内容的可见性即可。

总之，只有当迭代操作大于修改操作时，才应该使用 CopyOnWriteArrayList。否则大量的副本复制会造成显著的性能损耗。