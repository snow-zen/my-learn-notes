# 必要时进行保护性拷贝
#Java 

Java 用起来如此舒适的一个因素是，它是一门安全的语言。在一门安全语言中，在设计类的时候，可以确切地知道，无论系统的其他部分发生什么问题，这些类的约束都可以保持为真。

假设类的客户端会尽可能的破坏这个类的约束条件，因此你必须保护性地设计程序。面对客户端的不良行为时仍能保持健壮性的类，这是非常值得投入时间去做的事情。

> 在 Java 8 开始，修正这个问题最明显的方式是使用 Instant（或 LocalDateTime，或 ZonedDateTime）代替 Date，因为 Instant 是不可变的。Date 已经过时了，不应该在新代码中使用。

对于类内部存在可变实例时，在调用构造方法时每个可变参数进行保护性拷贝是必要的，并且使用备用对象作为实例的组件，而不使用原始的对象：

```java
public Period(Date start, Date end) {
	this.start = new Date(start.getTime());
	this.end = new Date(end.getTime());

	if (this.start.compareTo(this.end) > 0) {
		throw new IllegalArgumentException(this.start + " after " + this.end);
	}
}
```

另外，保护性拷贝需要在检查参数有效性之前进行，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。虽然看起来有点不太自然，但却是必要的，可以避免在“危险阶段”被另一个线程改变参数状态，危险阶段指检查参数开始到拷贝参数的时间段。

> ⚠️ 注意：对于可以被子类化的类型参数，请不要使用 clone 方法进行保护性拷贝。因为不能保证 clone 方法所返回的对象是否专门出于恶意目的设计的不可信子类的实例。

在客户端获取类实例的属性时，如果属性是可变实例则必须返回它的保护性拷贝。

保护性拷贝可能会带来相关的性能损失，这种说法并不总是正确。如果类信任它的调用者不会修改内部的组件，可能因为类及其客户端都是同一个包的双方，那么不进行保护性拷贝也是可以的。但在这种情况下，类的稳定中就必须清楚地说明，调用者绝不能修改受到影响的参数或者返回值。即使对于跨越包的作用范围，也不是必须进行保护性拷贝。这些方法要求客户端调用方法后承诺移交对象的所有权不再做任何操作 ，且在文档中明确指明这一点。