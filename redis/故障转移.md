# 故障转移
#Redis 

集群使用一个类似于 Raft 算法中的 ”term“ 概念。在 Redis 集群中该术语称为 epoch，它用于为事件提供增量版本控制。当节点收到相互冲突的消息时，可判断哪个消息是最新的。

## currentEpoch

`currentEpoch` 是一个无符号 64 位数。

在创建节点时，每个节点都将其设置为 0。节点每次收到数据包时，如果发送方的 `currentEpoch` 大于本地 `currentEpoch` ，则更新本地 `currentEpoch` 为发送方 `currentEpoch`。由于该语义，最终所有节点都会认同集群中 `currentEpoch` 最大的节点。

当集群的状态发生变化并且节点需要通过协议执行某些操作时，使用该信息。目前，仅在副本提升期间发送。

## configEpoch

`configEpoch` 在创建主节点时，由主节点设置为 0。

`configEpoch` 在副本提升为主节点时会重新创建。在试图替换失败的主节点时，会增加 `configEpoch` 并尝试从大多数主节点那里获取授权。

副本节点在发送心跳包时也会携带 `configEpoch` 字段，此时该字段表示其主节点上一次交换数据包时的 `configEpoch`。这用于其他节点检测副本所拥有配置的及时性，主节点在副本提升时不会向持有旧配置的副本投票。

每当已知节点的 `configEpoch` 发生变化时，所有接收到该消息的节点都会将其保持到 node.conf 文件中。`currentEpoch` 也是同样的。这两个变量在节点继续操作之前会将其保持并同步到磁盘中。

在故障转移期间，使用简单的算法保证生成的 `configEpoch` 是全新、增量和唯一的。

## 副本等级

一旦主节点处于 `FAIL` 状态时，副本在发起选举之前会延迟等待一段时间。该延迟计算如下：

```
DELAY = 500 milliseconds + random delay between 0 and 500 milliseconds +
        REPLICA_RANK * 1000 milliseconds.
```

该固定延迟可以确保 `FAIL` 状态在集群中充分传播，否则当副本发起选举时，其他主节点还不知道 `FAIL` 状态，则会拒绝投票。

> 随机延迟时间用于防止副本在同一时间发起选举。

`REPLICA_RANK` 是这个副本的等级，它与从主节点处理的复制数据量有关。当主节点处于 `FAIL` 状态时，副本会交换消息以建立等级：具有最新偏移量的副本等级为 0，第二多偏移量的副本为 1，依此类推。通过这种方式，具有最新偏移量的副本会尝试在其他副本之前被选中。

等级排名并没有严格执行，如果等级高的副本未能选举成功，其他副本将会尝试。一旦某个副本赢得了选举，它会得到一个全新、增量、唯一的 `configEpoch`，并且值高于已存在所有的主节点。此时它开始以主节点的身份在心跳包中推广自己，为一组已服务的哈希槽提供一个 `configEpoch`，它将赢得过去的哈希槽。

为了加速其他节点的重新配置，pong 数据包被广播到集群中的所有节点。当前无法访问的节点最终将从另一个节点的心跳包时重新配置，或者在检测到通过心跳包发送的数据过时时，将从另一个节点接收数据包进行更新。

其他节点检测到一个新主节点服务于旧主节点的相同哈希槽，且具有更大的 `configEpoch` 时，会升级它们的配置信息。旧主节点的其他副本不仅会升级配置，还会重新配置以从新主节点复制数据。

## 副本选举和提升

副本选举和提升是由副本节点自行处理，通过主节点投票支持该副本进行提升。

当满足以下条件时，副本开始选举：

+ 副本的主节点处于 `FAIL` 状态。
+ 主节点持有非零的哈希槽数量。
+ 副本与主节点的连接断开时间不超过指定值，以确保提升的副本所持有数据的完整度。该指定值是用户可以配置的。

满足条件后，该主节点下所有的副本节点都可以开始选举，但是只有一个副本节点会赢并且将自身提升为主节点。

选举时，副本的第一步就是增加其 `currentEpoch` 值。然后，副本会通过 `FAILOVER_AUTH_REQUEST` 向集群中每个主节点广播数据包来请求投票。副本会等待最多 `2 * NODE_TIMEOUT` 时间来等待响应。

一旦一个主节点投票给指定的副本，并通过 `FAILOVER_AUTH_ACK` 做出响应后，该主节点会在 `2 * NODE_TIMEOUT` 时间内不能给同一主节点下其他副本投票。在此期间，它也无法回复同一主节点下其他副本的投票请求，这对于防止多个副本被选举很有用。

如果 `FAILOVER_AUTH_ACK` 中的 `currentEpoch` 小于发送 `FAILOVER_AUTH_REQUEST` 时 `currentEpoch` 则该响应会被抛弃。这确保它不会将先前选举的投票计算进去。

一旦某个副本节点收到大多数主节点的确认，则它就会赢得选举。如果在 `2 * NODE_TIMEOUT` 时间内无法获得多数确认，则中止选举，并且在 `4 * NODE_TIMEOUT` 后再次尝试新的选举。

## 主节点响应投票请求

主节点接收副本发送的 `FAILOVER_AUTH_REQUEST` 请求进行投票。要获得投票，需要满足以下条件：

+ 每个主节点都会有一个 `lastVoteEpoch` 字段，只要投票请求包中的 `currentEpoch` 小于等于 `lastVoteEpoch` 就会拒绝投票。且当主节点对投票请求做出肯定答复时，`lastVoteEpoch` 会做相应的更新，并且安全的存储在磁盘中。
+ 只有当副本对应的主节点被标记为 `FAIL` 时，主节点才会进行投票。
+ 投票请求包中的 `currentEpoch` 比主节点的 `currentEpoch` 小时，则忽略。因此，主节点始终会响应具有相同 `currentEpoch` 的投票请求。如果同一副本再次发起投票请求并增加 `currentEpoch`，则可以保证新的投票请求不会接收来自主节点的旧的延迟响应。
+ 对于副本发送的投票请求中的 `configEpoch` 小于主节点所存储关于该哈希槽对应的 `configEpoch` 时，则不会进行投票。请记住，副本会发送其主节点的 `configEpoch`，以及其主节点持有哈希槽的位图。这意味着请求投票的副本必须具有它想要故障转移的插槽的配置，该配置必须是全新的或者等于主节点。

如果已投票给同一主节点下的其他副本，则在 `2 * NODE_TIMEOUT` 时间内不会响应。虽然这不是严格的，但是它可以确保选择一个副本时，它有足够的时间通知其他副本，并避免另一个副本赢得新的选举，从而执行不必要的第二次故障转移。

主节点并不会以任何方式选择最好的副本。如果副本的主节点处于 FAIL 状态，且主节点还未投票，则在收到投票请求时进行投票。但是好的副本拥有的排名更高，也更早进行投票。

当主节点拒绝投票时，并不会做出响应，该投票请求直接被忽略。

## configEpoch 冲突解决算法

在系统管理员手动执行重新分片和故障转移同时发生时，如果两个节点最终具有相同的 `configEpoch`，则执行以下操作：

+ 如果一个主节点检测到另一个主节点正在用相同的 `configEpoch`。
+ 如果该节点的节点 ID 的字典顺序小于另一个声称相同节点。
+ 然后它可将 `currentEpoch` 增加 1 作为新的 `configEpoch`。

如果有任何一组具有相同 `configEpoch` 的节点，则除了具有最大 Node ID 的节点外的所有节点都增加，从而保证最终每个节点都会选择一个唯一的 `configEpoch`。



