# 定义单元测试
#UnitTest 

从早期使用的 Smalltalk 编程语言开始的 20 世纪 70 年代开始，单元测试就已经出现，并一次又一次被证明是开发人员提高代码质量，加深理解类或方法功能需求的最佳手段之一。

单元测试的定义是在慢慢演化中的，从定义 1.0 开始：

> 一个单元测试是一段代码（通常是一个方法），这段代码调用了另一段代码，然后验证某些假设的正确性。如果这些假设是错误的，单元测试就失败。一个单元测试可以是一个方法或函数。

同时被测试的对象称为“被测试系统”（System Order Test，SUT）。

单元测试的这个传统定义在技术上是正确的，但随着时间的推移，**单元**这个概念发生了改变，一个单元代表系统中的“功能单元”或者一个“用例”。

单元的定义如下：从调用系统的一个公共方法到产生一个测试可见的最终结果，其间这个系统发生的行为总称为一个**工作单元**。我们可以通过系统的公共 API 和行为就可以观察到一个可见的最终结果，无需查询系统内部状态。一个最终结果可以是以下任何一种形式：

+ 被调用的公共方法返回一个值（一个返回值不为空的函数）。
+ 在方法调用的前后，系统的状态或行为有可见的变化，这种变化无需查询私有状态即可判断。
+ 调用了一个不受测试控制的第三方系统，这个第三方系统不返回任何值，或者返回值都被忽略。

因此工作单元中，单元既可以小到只包含一个方法，也可以大到包括实现某个功能的多个类和函数。

> ⚠️ 注意：也许你觉得被测试的工作单元应该尽可能的小。如果你创建的工作单元更大，而且它的最终结果对这个接口的用户可见度更高，那么我相信测试会更好维护。如果你试图把工作单元缩到最小，最后会不得不伪造一堆东西，这些东西并不是使用公共 API 的真实最终结果，而是生成结果过程中一些中间状态。

定义更新 1.1：

> 一个单元测试是一段代码，这段代码调用一个工作单元，并检验该工作单元的一个具体的最终结果。如果关于这个最终结果的假设是错误的，单元测试就失败了。一个单元测试的范围可以小到一个方法，大到多个类。

不管使用哪种编程语言，最困难的就是定义“优秀”的单元测试。

## 编写优秀单元测试的重要性

要理解单元测试，仅能理解什么是工作单元是不够的。

大部分人在编程时会遇到以下问题：

+ 在某个阶段放弃了，或者并没有真正执行单元测试。
+ 依靠在产品生命周期后期执行的系统测试和集成测试来发现问题。
+ 改用手工方式，使用定制的测试应用程序或者最终产品调用代码来进行测试。

编写差劲的单元测试是没有意义的，除非你在学习中。要理解什么是优秀的单元测试，需要理解开发人员在测试的时候都做些什么。

## 我们都写过单元测试

大部分开发人员都会在提交代码前对代码进行测试。通常是使用一个手工的外部工具进行反复验证，或者运行整个应用程序，手工验证它的行为。

这种测试也许很有用，而且可能也很接近传统定义的单元测试，但是它们和我们定义的优秀的单元测试还有很大的区别。