# JVM 关闭
#Java #Multithreading 

JVM 即可以正常关闭，也可以强行关闭。

正常关闭的触发方式：

+ 最后一个非守护进程结束时。
+ 调用 System.exit 方法。
+ 向程序发送 SIGINT 信号或键入 `ctrl + c`。

强行关闭的触发方式：

+ 调用 Runtime.halt 方法。
+ 向程序发送 SIGKILL 信号。

## 关闭钩子

关闭钩子通过 Runtime.addShutdownHook 方法注册到尚未开启的线程中。在正常关闭过程中， JVM 首先调用所有已注册的 Shutdown hook。

> ⚠️ 注意：JVM 并不能保证关闭钩子的调用顺序。

程序关闭的过程：

+ 如果有其他线程仍然在运行，则这些线程会与关闭进程并发执行。
+ 当所有的关闭钩子都执行完成，如果 runFinalizersOnExit 参数为 true，则 JVM 将运行终止器后再停止。
+ JVM 不会停止或中断任何关闭时仍在运行的线程，但是当 JVM 最终结束时这些线程会被强行结束。
+ 如果到最后关闭钩子和终结器没有执行完成，那么正常关闭进程“挂起”并且 JVM 必须强制关闭。

> ⚠️ 注意：当强制关闭时，只是关闭 JVM 而不会运行关闭钩子。

**关闭钩子应该是线程安全的**：与其他并发代码相同，关闭钩子应该在访问共享变量时必须使用同步机制，并且要避免死锁。同时关闭钩子不应该对应用程序的状态作出任何假设，编写代码时应考虑周全。

**关闭钩子应该是快速执行的**，因为它们会延迟 JVM 的结束时间，而用户可能希望 JVM 能尽快终止。

**关闭钩子可用于清除资源**。关闭钩子可以用于实现服务或应用程序的清理工作，例如删除临时文件、清除无法由操作系统自动清除的资源。

**对所有服务使用同一个关闭钩子**。由于关闭钩子是并发执行，为了避免关闭钩子依赖那些可能被应用程序或其他关闭钩子关闭的服务，所有服务应使用同一个关闭钩子，在一个关闭钩子中作一系列操作。

> 这确保来关闭操作在单个线程中串行执行，避免关闭过程中出现竞态条件或死锁等潜在故障。

## 守护进程

使用场景：希望创建一个线程来执行一些辅助操作，但又不希望这个线程阻碍 JVM 的关闭。在这种情况下就需要使用守护线程。

线程可分为两种：普通线程和守护线程。在 JVM 启动时创建的线程中，除主线程外其他线程都是守护进程（例如：垃圾回收器以及其他执行辅助工作的线程）。新线程的创建取决于创建它的线程的守护状态，因此在默认状态，主线程创建的线程都是普通进程。

普通线程和守护线程的区别在于线程退出时的操作：当 JVM 退出时，会检查所有正在运行的其他线程，如果线程为守护线程，那么 JVM 会正常执行退出操作。当 JVM 停止时，所有仍存在的守护进程都会被抛弃，即不会执行 finally 代码块，也不会执行回卷栈，而 JVM 只是直接退出。

应尽少使用守护线程，因为很少有操作可以在不进行清理的情况下被安全的抛弃。守护进程最好用于执行“内部任务”，例如周期性地从内存的缓存中移除逾期的数据。

> 此外，守护线程通常不能用来替代应用程序管理程序中各个服务的生命周期。

## 终结器

终结器可用于在一些系统资源不需要时，可通过垃圾回收器调用定义的 finalize 方法对其进行释放。如果对象定义了，回收器会在释放对象时，调用对象的finalize方法。

由于终结器可以在某个由 JVM 管理的线程中运行，因此终结器访问的任何状态都可能被多个线程访问，这就必须对访问操作进行同步。同步操作会增大对象操作的复杂性，同时带来巨大的性能消耗。大多数情况下，通过使用finally代码块和显式的close方法，能更好的管理资源。

唯一的例外情况在于：当需要管理对象，并且该对象持有的资源是通过本地方法获得的。基于这些原因以及其他一些原因，我们要尽量避免编写或使用包含终结器的类。[^1]

[^1]: [[避免使用 finalize 和 clear 方法]]



