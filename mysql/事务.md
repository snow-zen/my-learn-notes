# 事务
#MySQL 

事务就是一组原子性的 SQL 查询。

## ACID

一个运行良好的事务必须具备四大特性：

**原子性（Atomicity）**

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。

对于一个事务来说，不可能只执行其中的一部分操作。

**一致性（Consistency）**

数据库总是从一个一致性状态转为另外一个一致性状态。在事务提交前的修改都不会保存到数据库中。

**隔离性（Isolation）**

一个事务所做的修改在最终提交前，对其他事务是不可见的。

**持久性（Durability）**

一旦事务提交，则其所做的修改就会永久保存到数据库中。

事务的处理过程中额外的安全性，也会需要数据库系统做更多的额外工作。

## 隔离级别

针对事务的隔离性，在 SQL 标准中定义了四种隔离级别：

**READ UNCOMMITTED**

在 READ UNCOMMITTED 级别下，事务中的修改，即使没有提交，对其他事务也都是可见的。由于事务可以读取到未提交的数据，这也被称为脏读。

**READ COMMITTED**

大多数数据库默认的隔离级别就是 READ COMMITED，事务开始时，只能看见以提交的事务所做的修改。从另一个角度说，事务开始到提交前，所做的任何修改对其他事务都是不可见的。

但是，这个级别也会出现不可重复读的情况，执行两次相同的查询会出现不一致的结果。

**REPEATABLE READ**

REPEATABLE READ 解决了脏读的问题。该级别保证了同一个事务中多次读取相同记录的结果是一致的。

但是理论上，该级别还是无法解决另一个幻读问题。幻读是指当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入新的记录，当之前的事务再次读取该范围内记录时，会产生幻行。

InnoDB 和 XtraDB 存储引擎通过多版本并发控制解决了幻读的问题。

> REPEATABLE READ 是 MySQL 默认事务隔离级别。

**SERIALIZABLE**

SERIALIZABLE 是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读问题。

实际应用中也很少使用到这个隔离级别，只有在非常需要确保数据一致性而且可以接受没有并发的情况下，才考虑该级别。

| 隔离级别         | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| ---------------- | ---------- | ---------------- | ---------- | ------ |
| READ UNCOMMITTED | Yes        | Yes              | Yes        | No     |
| READ COMMITTED   | No         | Yes              | Yes        | No     |
| REPEATABLE READ  | No         | No               | Yes        | No     |
| SERIALIZABLE     | No         | No               | No         | Yes    |


