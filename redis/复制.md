# 复制
#Redis 

Redis 复制是支持高可用和故障转移的基础，它允许副本实例成为主实例的精确副本。每次连接断开时，副本实例都会重新连接到主实例，并且无法发送什么情况，都会尝试成为它的精确副本。

该复制机制主要使用三种机制工作：

1. 当主实例和副本实例连接良好时，主实例向副本实例发送命令流来保持副本的及时更新。影响主实例数据集的命令有：写入操作、键过期或被删除、修改操作。
2. 当主实例和副本实例连接超时或断开时，副本会尝试重新连接并尝试部分重新同步；这表示它仅获取部分在断开连接时错过的命令流。
3. 当无法进行部分重新同步时，副本实例将请求完全重新同步。主实例会创建一个 RDB 快照并发送至副本，之后随着数据集的变化发送命令流。

Redis 默认使用异步同步，它具有低延迟、高性能的特性。副本实例也会异步确认它们与主机定期接收的数据量，因此主实例无需等待副本处理命令。但是如果主实例需要知道副本是否已处理命令则可以使用同步复制。

客户端可以发送 `WAIT` 命令在写入操作时进行同步复制，但是该命令只能保证其他 Redis 实例中有指定数量已确认的副本，它并不会讲 Redis 实例变为具有强一致性的 CP 系统。

> 虽然使用 WAIT 在出现失败情况下丢失写入的概率会大大降低，但是同步复制也意味着要牺牲 Redis 的一部分吞吐量。

## 关于复制的重要特点

一个主实例可以有多个副本实例。副本除了与主实例建立连接外，还可以与其他副本建立连接。

由于复制是异步、非阻塞的，主实例在处理副本实例的初始同步或部分同步时，也可以继续处理查询。对于副本实例来说，复制很大程度也是非阻塞的。你可以配置在初始同步时它可以使用旧版本的数据集来处理查询，还可以配置在复制流停止时向客户端返回错误。在初始同步完成后，必须删除旧数据集加载新数据集。副本实例将在这段时间内阻止客户端接入。

> Redis 4.0 开始，可以配置将旧数据集的删除在其他线程中完成，但是加载新数据集还是在主线程中进行且会阻塞副本实例。

副本实例除了可以用于实现高可用外，它也可以承担只读操作的处理。

一种典型的技术配置可以避免主实例在持久化数据到磁盘的成本：在主实例中不开启持久化选项，然后连接配置了 RDB 或 AOF 的副本实例。但是需要额外注意的是，重启后的主实例是个空数据集，如果此时副本尝试与其同步，则副本也将被清空。

## 主实例关闭持久化机制的复制安全性

有一种典型的技术配置可以避免主实例在持久化数据到磁盘的成本：在主实例中不开启持久化选项，然后连接配置了 RDB 或 AOF 的副本实例。

> ⚠️ 注意：需要额外注意的是，重启后的主实例是个空数据集，如果此时副本尝试与其同步，则副本也将被清空。

因此在使用复制时，强烈建议在主实例和副本实例都开启持久化机制。如果没有办法做到这一点，则应将实例配置为避免自动重启。

总之，为了保证数据的安全性，在没有设置持久化机制的主实例上使用复制时，应该禁用实例的自动重启。

## 复制工作原理

复制 ID 是一个伪随机的字符串，用于标记数据集。每个实例还存在一个偏移量，偏移量随着要发送副本实例的命令的增加而增加。即使没有副本实例连接，偏移量也同样会增加。因此基本上通过复制 ID 和偏移量即可确定数据集当前的版本。

当副本连接主实例时，有以下步骤：

1. 通过 `PSYNC` 命令发送旧主实例的复制 ID 和当前的偏移量。
2. 接受到的主实例检查副本发送的复制 ID 是否存在已知的历史记录中。
	+ 存在并且缓存区有足够的数据时，则只发送所需的增量数据。
	+ 不存在或者缓存区没有足够的数据时，则重新同步。

完全同步时工作方式如下：

![Redis 主从完全同步工作流程](https://my-images-repo.oss-cn-hangzhou.aliyuncs.com/redis/Redis%20%E4%B8%BB%E4%BB%8E%E5%AE%8C%E5%85%A8%E5%90%8C%E6%AD%A5%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

1. 主实例异步生成 RDB 文件，同时缓存之后接到的命令。
2. RDB 文件生成后，将文件传输到副本实例。副本实例保存到自身磁盘，然后加载到内存中。
3. 传输完成后，将缓存的命令通过命令流的方式发送到副本实例。

当主从连接断开后，副本可以自动连接。如果主实例接收到多个并发的副本同步请求，则会生成单个 RDB 文件以服务所有请求。

## 复制 ID

复制 ID 标记了数据集的给定历史记录。每次实例作为主实例从头开始重新启动，或者副本被提升为主实例时，都会为实例分配一个新的复制 ID。

连接到主实例的副本实例则会继承主实例的复制 ID。因此具有相同复制 ID 的两个实例具有相同的数据集，但可能在不同的时间领先程度不一样，偏移量可以理解为逻辑时间。

主实例可以有两个复制 ID，一个主 ID 和一个辅助 ID，这在副本实例提升为主实例时就会出现的情况。故障转移后，新主实例仍然需要记住过去的复制 ID，因此前面的主副本之间是使用该复制 ID 进行同步的。

当其他副本使用过去的复制 ID 与新主实例同步时，这可以正常工作。因为原副本实例在切换为新主实例时，会将原有从旧实例继承过来的复制 ID 切换为主复制 ID，并且记住切换时刻的偏移量，然后它会生成一个新的随机复制 ID，标志新的历史开始。在处理新副本连接时，新主实例会将它们的复制 ID 和偏移量与当前的复制 ID 和辅助 ID 进行匹配。

至于为什么要在升级为主实例后更改其复制 ID：由于某些网络分区，旧的主实例可能仍在工作。保留相同的复制 ID 会违反以下事实：任何两个随机实例的相同 ID 和相同偏移量意味着它们具有相同的数据集。

## 复制下处理过期键问题

Redis 并不依赖主实例和副本之间拥有同步时钟的能力，因为这是一个无法解决的问题。因此 Redis 使用三种主要技术来使过期键可以在复制时能正常工作：

1. 副本实例不会使键过期，而是等待主实例使键过期。当主实例使键过期时，它会合成一个 `DEL` 命令发送到所有副本实例。
2. 然而由于主实例在键过期到发送命令中存在延迟，因此主实例无法及时提供 DEL 命令。为了解决这个问题，副本使用逻辑时钟检查键是否过期，仅用于不违法数据唯一性的读取操作。通过这种方式，副本避免报告逻辑上过期的密钥仍然存在。
3. 执行 Lua 脚本时，不会执行键过期操作。从概念上认为 Lua 脚本执行期间，时间被冻结了，给定的键要么存在，要么不存在，类似于一致性。

一旦副本实例提升为主实例，它可以独立处理键过期操作。

## 副本实例中的 Maxmemory

默认情况下，副本实例的 `maxmemory` 配置将被忽略。这意味着键的驱逐讲由主实例来处理。因此需要确保副本实例的内存需要大于或等于主实例内存，防止出现内存不足的情况。

要更改此行为，可允许副本不忽略 `maxmemory`：

```config
replica-ignore-maxmemory no
```








