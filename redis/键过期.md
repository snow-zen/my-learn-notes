# 键过期
#Redis 

当使用 Redis 作为缓存时，可以通过设置键过期策略在内部键的存储量达到一定数量时，执行相应策略清除键释放额外空间。

## 过期与持久化

键的过期信息存储的是绝对的 Unix 时间戳，这意味着即使 Redis 实例不活动，时间仍在流逝。

> ⚠️ 注意：在集群模式下，为了使过期能够正常工作，集群中的计算机时间必须保持稳定。如果在两台时钟严重不同步的计算机上进行主从复制操作，则所有携带过期时间的键在被复制到目标计算机时就已过期。

## 过期检测

当客户端尝试访问键时，如果键携带过期时间，则对其进行过期检测。如果键已过期，则删除键并返回空，否则正常返回键。

考虑到有过期的键可能永远不会被再次访问，但这些键始终都应该过期，因此 Redis 会每秒进行以下操作：

1. 从已关联过期时间的键集合中随机抽取 20 个 键进行测试。
2. 删除所有已过期的键。
3. 如果超过 25% 的键过期，则从步骤 1 重新开始。

## 最大内存限制

`maxmemory` 配置用于限制单个 Redis 实例所能存储键最大空间。

例如，限制 100 Mb 内存空间：

```conf
maxmemory 100mb
```

当配置值设置为 0 时，对于 64 位系统则没有任何限制，而对于 32 位系统则使用默认最大 3 GB 内存限制。

当 Redis 实例中键的占用空间达到指定大小时，则会触发过期策略的执行。

## 过期策略

`maxmemory-policy` 配置用于在达到内存限制时，执行不同的过期行为。可以使用的策略如下：

+ **noeviction**：达到内存限制时，返回错误信息。
+ **allkeys-random**：随机删除键。
+ **allkeys-lru**：删除最近最少使用的键。
+ **allkeys-lfu**：删除最不常用的键。
+ **volatile-random**：随机删除已设置过期值的键。
+ **volatile-lru**：删除最近最少使用的已设置过期值的键。
+ **volatile-lfu**：删除最不常用的已设置过期值的键。
+ **volatile-ttl**：删除过期时间最短的已设置过期值的键。

其中 allkeys-lfu 和 volatile-lfu 策略是在 Redis 4.0 新加入的策略。

如果 volatile-random、volatile-lru、volatile-lfu、volatile-ttl 策略没有匹配到的键时，则行为会和 noeviction 类似。

> 另外需要注意的是，匹配已设置过期值的键会额外消耗内存，因此使用 allkeys-lru 之类的策略会提高内存效率，因此不需要考虑过期值。

## 近似 LRU 算法

Redis 中的 LRU 算法不是一个精确的实现。它实现了一种近似的 LRU 算法，通过对少量键进行采样，并过期采样键中匹配项。

Redis LRU 算法的重要之处在于，可以通过更改样本数量来调整算法的精度：

```conf
maxmemory-samples 5
```

Redis 不使用真正的 LRU 实现的原因是它需要更多的内存消耗。

