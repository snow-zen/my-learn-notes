# 在任务与执行策略之间的隐性耦合
#Java #Multithreading 

Executor 可以将任务的提交和执行策略解耦开来，为制定和修改执行策略提供相当大的灵活性，但并非所有的任务都能适用所有的执行策略。有些类型的任务需要明确指定执行策略：

**依赖性任务**。虽然大多数任务都是独立的，但还是会出现以下情况：某个任务的执行依赖于另一个任务的执行结果。当在线程池中执行独立的任务时，可以随意地改变线程池的大小和配置，这些修改只会对执行性能产生影响。然而，如果提交给线程池的任务需要依赖其他的任务，那么就隐含地给执行策略带来约束，此时必须小心地维护这些执行策略以避免产生活跃性问题。

**使用线程封闭机制的任务**。相比于线程池，单线程的 Executor 能够对并发性提供更强的承诺。

单线程 Executor 的优点：

+ 保证任务不会并发执行，使得可以放宽对代码线程安全性的要求。
+ 执行的任务在访问对象时不需要同步，即使资源不是线程安全性的。

> ⚠️ 注意：通过单线程的 Executor 所实现的线程封闭机制的任务和执行策略之间形成了隐式的耦合。如果 Executor 改为线程池环境时，任务会失去线程安全性。

**对响应时间敏感的任务**。例如 GUI 应用程序对于响应时间是敏感的，将一个运行时间较长的任务提交到单线程 Executor，或者多个任务提交到运行时间较长的任务中都会降低该 Executor 管理服务的响应性。

**使用ThreadLocal的任务**。ThreadLocal 可以使得每个线程都可以拥有某个变量的一个私有“版本”。然而，线程池中的线程并不会一直不变，在某个线程抛出未检查异常、任务变多、线程空闲时都会引起线程的增加和减少。因此在线程池中，只有当 ThreadLocal 变量值的生命周期受限于任务的生命周期时，ThreadLocal 的使用才有意义。

> 在线程池中不应该使用 ThreadLocal 在任务之间传递值。

只有当任务都是同类型的独立任务时，线程池的性能才能达到最佳。如果运行时间长和运行时间较短的任务混合在一起，除非线程池很大，否则可能造成“拥塞”。如果提交的任务依赖其他任务时，除非线程池很大，否则可能会造成死锁。

> 在一些任务中，需要拥有或排除某种特定的执行策略。如果某些任务依赖于其他的任务，那么会要求线程池足够大，从而确保它们依赖任务不会被放入等待队列中或被拒绝，而采用线程封装机制的任务需要串行执行。通过将这些需求写入文档，将来的代码维护人员就不会由于使用了某种不合适的执行策略而破坏安全性或活跃性。

## 线程饥饿死锁

单线程的 Executor 中，如果一个任务将另一个任务提交到同一个 Executor 并等待结果则可能产生死锁。而更大的线程池中，如果所有正在执行的任务都由于等待其他仍处于工作队列中的任务而阻塞时，也会引发同样的问题。

这类现象被称为线程饥饿死锁。

> ⚠️ 注意：只要线程池中任务需要无限期的等待一些必须由池中其他任务才能提供的资源或条件，则可能会发生线程饥饿死锁。

例如，在单线程 Executor 中任务发送死锁：

```java
public class ThreadDeadLock {

    private ExecutorService exec = Executors.newSingleThreadExecutor();

    public class RenderPageTask implements Callable<String> {
        @Override
        public String call() throws Exception {
            Future<String> header;
            Future<String> footer;
            header = exec.submit(new LoadFileTask("head.html"));
            footer = exec.submit(new LoadFileTask("footer.html"));
            // 可能发生死锁，由于等待子任务的结果
            return header.get() + footer.get();
        }
    }

    public class LoadFileTask implements Callable<String> {

        private final String fileName;

        public LoadFileTask(String fileName) {
            this.fileName = fileName;
        }

        @Override
        public String call() throws Exception {
            return "";
        }
    }
}
```

每当提交一个有依赖性的任务到 Executor 时，要清楚知道可能会出现线程“饥饿”死锁，因此需要在代码或配置 Executor 的配置文件中记录线程池的大小限制或配置限制。

除了线程池大小的限制外，还可能由于其他资源上的约束而存在一些隐式限制。例如：应用程序中有一个包含 10 个连接的 JDBC 连接池，并且每个任务需要一个数据库连接，那么线程池就好像只有 10 个线程，因为当超过 10 个任务时，新的任务需要等待其他任务释放连接。

## 运行时间较长的任务

在任务阻塞的时间过长时，那么即使不出现死锁，线程池的响应性也会变得糟糕。执行较长的任务不仅会造成线程池堵塞，甚至还会增加执行时间较短的任务的服务时间。

如果线程池中的线程数量远小于在稳定状态下执行时间较长的任务的数量，那么最后可能所有的线程都会运行这些执行时间较长的任务，从而影响整体的响应性。

可通过限定任务等待资源时间，而不要无限制的等待来缓解执行时间长的任务造成的影响。操作步骤为：

1. 提交任务到线程池，线程进入工作队列。
2. 调用者通过 Thread.join、BlockingQueue.put、CountDownLatch.await 以及 Selector.select 指定等待时间获取结果。
3. 如果等待超时时，把任务标识为失败。
4. 中止任务，任务重新加入工作队列以便随后执行。

这样无论最终结果如何，都能确保任务总能继续执行下去，并将线程释放出来以执行一些能更快完成的任务。如果在线程池中总是充满了被阻塞的任务，那么也可能表明线程池的规模过小。