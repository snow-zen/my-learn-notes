# 对象的分配规则
#Java #JVM 

大多数情况下，对象在新生代 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机则发起一次 Minor GC。

> HotSpot 虚拟机提供了 -XX:+PrintGCDetails 参数在垃圾收集时打印内存回收日志，并且在进场退出时输出当前内存各区域分配情况。在实际的问题排查中，收集器日志常会打印到文件中通过工具进行分析。

当 Minor GC 后存活的对象不足以放到 Survivor 区中，则启动分配担保机制提前转移到老年代中去。

## 大对象直接进入老年代

大对象指需要大量连续内存空间的 Java 对象，例如：长字符串、元素数量庞大的数组。大对象对虚拟机内存分配来说就是一个不折不扣的坏消息，比遇到一个大对象更加坏的消息就是遇到一群 “朝生夕灭” 的 “短命大对象”，因此写程序时应极力避免。

避免大对象的原因是，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获得足够的空间放置它们，而当复制对象时，大对象意味着高额的内存复制开销。

> HotSpot 虚拟机提供了 -XX:PretenureSizeThreshold 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在 Eden 区和两个 Survivor 区之间来回复制，产生大量开销。注意，该参数只对 Serial 和 ParNew 两款新生代收集器有效。

## 长期存活对象进入老年代

虚拟机给每个对象都定义了一个对象年龄计数器，存储在对象头中。新对象通常在 Eden 区中分配，如果经过一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，该对象会被移动到 Survivor 区中，并且将其对象年龄设置为 1。对象每熬过一次 Minor GC，年龄就增加 1，当它的年龄增加到阈值，就会被晋升到老年代中。

> 对象晋升老年代的阈值，可以通过参数 -XX:MaxTenuringThreshold 设置，默认为 15。

## 动态对象年龄判断

为了适应不同程序的内存状况，HotSpot 虚拟机并不是永远要求对象的年龄必须达到 -XX:MaxTenuringThreshold 才能晋升老年代。

如果在 Survivor 区中相同年龄对象的所占空间总和大于 Survivor 区一半，则年龄大于或等于该年龄的对象就可以直接进入老年代，无须等待 -XX:MaxTenuringThreshold 要求的年龄阈值。

## 空间分配担保

在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这次 Minor GC 则可以确保是安全的。如果条件不成立，则虚拟机会查看 -XX:HandlePromotionFailure 参数值是否允许担保失败；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管是有风险的；如果小于，或者 -XX:HandlePromotionFailure 不允许冒险，则改为一次 FullGC。

![空间分配担保判定](https://my-images-repo.oss-cn-hangzhou.aliyuncs.com/jvm/%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E5%88%A4%E5%AE%9A.png)

当新生代使用标记 - 复制算法时，极端情况下新生代中所有的对象都存活，此时 Survivor 区无法则需要老年代来进行分配担保，将 Survivor 区无法容纳的对象直接送入老年代。

老年代在执行分配担保前，需要检查自身剩余是否具备担保的资质。但一共有多少对象会在这次回收中存活下来在实际完成内存回收之前是无法明确知道的，所以只能取之前每次回收晋升到老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行 Full GC 让老年代腾出更多空间。

取历史平均值其实仍然是一种赌概率的解决办法，也就是说假如某次 Minor GC 后存活对象突增，远高于平均值，依然会导致担保失败。担保失败后，则重新发起 Full GC，这样停顿时间就很长。

> 虽然担保失败时会绕的圈子是最大的，但通常情况下都还是会将 -XX:HandlerPromotionFailure 开关打开，避免 Full GC 过于频繁。

