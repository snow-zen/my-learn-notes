# 只针对异常的情况才使用异常
#Java 

假设你碰到这样的代码：

```java
try {
	int i = 0;
	while(true)
			range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```

代码中使用抛出异常的方式来作为数组遍历完成后的循环停止，这种构想是非常拙劣的。他们企图利用 Java 的错误判断机制来提高性能，因为 VM 对每次数组访问都要检查越界情况，所以他们认为正常的循环终止测试被编译器隐藏了，但在 for-each 循环中仍然可见，这无疑是多余的，应该避免。

这种想法存在三个错误：

1. 异常机制的设计初衷是用于不正常的情形，所以几乎没有 JVM 实现试图对它们进行优化，使它们与显式的测试一样快速。
2. 把代码放在 try-catch 块中反而阻止了现代 JVM 实现本来可能要执行的某些特定优化。
3. 对数组进行遍历的标准模式并不会导致冗余的检查。有些现代的 JVM 实现会将它们优化掉。

实际上，基于异常的模式比标准模式要慢得多，且它会模糊代码的意图，降低它的性能，还不能保证正常的工作。

> 异常应该只用于异常的情况下，它们永远不应该用于正常的控制流。

设计良好的 API 不应该强迫它的客户端为了正常的控制流而使用异常。如果类具有“状态相关”的方法时，只有在特定条件下才可以被调用的方法，这个类往往也应该有个单独的“状态测试”方法。

另一种提供单独的状态测试方法是，如果“状态相关”的方法无法执行想要的计算，就让它返回一个零长度的 optional 值[^1]，或者返回一个可识别的值，比如 null。

[^1]: [[谨慎返回 optional]]

对于上述“状态测试方法”和“optional 返回值可识别的返回值”这两种做法，有些指导原则可以帮助你在两者之间做出选择。

1. 如果对象将在缺乏外部同步情况下被并发访问，或可以被外部改变状态，就必须使用 optional 返回值或可识别的返回值，因为调用“状态测试方法”和调用对应的“状态相关”方法的时间间隔中，对象的状态可能会发生变化。
2. 如果单独的“状态测试”方法必须重复“状态相关”方法的工作时，从性能的角度看，就应该使用可被识别的返回值。如果其他方面都是等同的，则“状态测试”方法则略优于可被识别的返回值。它提供了稍微更好的可读性，对于使用不当的情况可能更易于检测和更正：如果忘记了去调用状态测试方法，状态相关的方法就会抛出异常，使得这个 bug 变得很明显；如果忘了去检查可识别的返回值，这个 bug 就会很难被发现。optional 返回值则不会有这样的问题。



