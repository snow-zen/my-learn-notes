# 线程引入的开销
#Java #Multithreading 

比起单线程，多线程需要线程调度、同步开销、使用锁保证数据一致性等额外开销。因此引入多线程来提升性能，必须满足多线程的额外开销小于并行带来的性能提升。

## 上下文切换

当可运行的线程大于 CPU 数量，那么操作系统最终会将某个正在运行的线程调度出来，从而使其他线程能够使用 CPU。线程的每次调用都会导致一次上下文的切换，在这个过程中会把当前运行线程的执行上下文保存，并将新调度进来的执行上下文设置为当前上下文。

切换上下文需要开销，而且切换过程中需要访问由操作系统、JVM 共享的数据结构。因此应用程序、操作系统、JVM 都使用一组相同的 CPU。在 JVM 和操作系统的代码中消耗越多的 CPU 时钟周期，则应用程序的可用时钟周期就越少。同时切换上下文还可能伴随缓存的失效。当一个线程被切换到时，可能当前处理器上的本地缓存中没有它所需的数据，因此线程在首次调度时会更加缓慢。

由于这些原因调度器会给每个可运行的线程分配一个最小的执行时间，即使有许多其他的线程正在等待执行：它将上下文切换的开销分摊到更多不会中断的的执行时间上，从而提高整体的吞吐量（以损失响应性为代价）。

当线程由于等待某个发生竞争的锁被阻塞时，通常会被 JVM 挂起，并允许交换出去。在程序中出现的阻塞越多，与 CPU 密集型程序就会发生越多的上下文切换，从而增加调度开销，并因此而降低吞吐量。

上下文的实际切换开销根据平台的不同而变化，然后大多数通用的处理器中，上下文切换的开销相当于 5000～10000 个时钟周期，也就是几微秒。

UNIX 系统的 vmstat 命令和 Windows 系统的 perfmon 工具都能报告上下文切换次数以及在内核中执行时间所占比例等信息。如果内核占用率较高（超过 10%），那么通常表示调度活动发生得很频繁，这很可能是由 I/O 或竞争锁导致的阻塞引起的。

## 内存同步

同步操作的性能开销存在多个方面。在 synchronized 和 volatile 提供的可见性保证中可能会使用一些特殊指令 —— 内存栅栏。内存栅栏可以刷新缓存，使缓存无效，刷新硬件的写操作，以及停止执行管道。同时也将抑制编译器的优化，大多数操作不可被重排序。

同步分为有竞争的同步和无竞争的同步，synchronized 对无竞争同步进行了优化，volatile 也是无竞争的。虽然无竞争同步消耗不为零，但对整个应用程序的影响微乎其微。

现代 JVM 可以通过优化来去除一些不好发生竞争的锁，减少不必要的同步开销。一些更完善的 JVM 可以通过逸出分析局部变量，从而去除加锁。即使不进行逸出分析，编译器也会支持锁消除优化，分析合并代码减少加锁次数。

某个线程的同步可能影响其他线程的性能。同步会增加共享内存总线上的通信量，总线的带宽是有限的，并且所有处理器都将共享这条总线。

## 阻塞

非竞争的同步可以通过 JVM 来进行处理，而竞争的同步可能需要操作系统的介入。当锁发生竞争时，竞争失败的线程会被阻塞。JVM 在阻塞时使用自旋锁或操作系统挂起被阻塞的线程。

如果等待时间较短，适合使用自旋锁；如果等待时间较长，则适合采用线程挂起的方式。有些 JVM 会根据历史等待时间的分析数据进行方式的选择，但大部分 JVM 都只是将线程挂起。

当线程需要被挂起时，这个过程中包含两次额外的上下文切换，以及所有必要的操作系统操作和缓存操作：被阻塞的线程在其执行时间片还未用完之前就被交换出去，而在随后当要获取的锁或者其他资源可用时，又再次被切换回来。

