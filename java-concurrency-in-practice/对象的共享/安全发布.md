# 安全发布
#Java #Multithreading 

我们在得知如何防止对象发布后，某些情况下我们也需要知道如何正确发布对象，不正确的发布会导致对象被破坏。

例如，通过不正确的方式发布对象：

```java
public class Holder {
    
    private int n;

    public Holder(int n) {
        this.n = n;
    }

    public void assertSanity() {
        if (n != n) {
            throw new AssertionError("The statement is false.");
        }
    }
}
```

例子的问题不在 Holder 类本身，而是在 Holder 类未被正确的发布。当对象被发布时，其他线程可能看到 Holder 属性是一个失效值，因此将看到一个空引用或者之前的旧值。

如果没有足够的同步机制，那么在发布后多线程下会由于失效数据等原因导致一些奇怪的问题。

## 不可变对象与初始化安全

由于不可变对象是 Java 中一种非常重要的对象。因此 Java 内存模型为不可变对象提供了一种特殊的初始化安全保证。

即使在发布不可变对象的引用时没有使用同步，也仍然可以安全地访问该对象。 为了维持这种初始化安全性的保证，必须满足不可变性的所有需求：状态不可修改，所有属性都是 final 类型，以及正确的构造方法。

> 任何线程都可以在不需要额外同步的情况下安全的访问不可变对象，即使在发布这些对象时没有使用同步。

这种保证还可以延伸到正确创建对象中所有 final 类型的域。在没有额外的同步机制时，也可以安全的访问这些 final 类型的域。但如果 final 域所指向的是可变对象，那么在访问这些域所指向的对象时还是需要同步。

## 安全发布的常用模式

可变对象通常在发布和使用该对象时使用同步才能保证安全发布。

要安全的发布对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式安全发布：

+ 在静态初始化函数中初始化对象引用。
+ 将对象的引用保存到 volatile 类型的域或者 AtomicReferance 对象中。
+ 将对象的引用保存到某个正确构造对象的 final 类型域中。
+ 将对象的引用保存到一个由锁包含的域中。

> 利用线程安全容器（例如 Vector、synchronizedList）内部同步，将对象放入容器中，这将满足最后一种方式。

而如果要发布一个静态构造的对象，最简单的方式就是使用静态的初始化器：

```java
public static Holder holder = new Holder(42);
```

静态初始化器由 JVM 在类的初始化阶段执行。由于 JVM 内部存在同步机制，因此这种方式初始化的任何对象都会被安全的发布。

## 事实不可变对象

如果对象从技术上看是可变的，但其状态在发布后不会再改变，那么把这种对象称为”事实不可变对象“。这类对象不需要满足不可变对象的严格定义。同时这些对象发布后，程序只需要将它们视为不可变对象即可。

通过使用事实不可变对象，不仅可以简化开发过程，同时还能由于减少同步而提高性能。

## 可变对象

对于可变对象不仅要在发布时使用同步，在后续每次访问对象时同样也需要使用同步。而如果想安全的共享对象，那对象就需要被安全的发布，并且必须是线程安全的或由某个锁保护起来。

对象的发布需求取决于它的可变性：

+ 不可变对象可以通过任意机制来发布。
+ 事实不可变对象必须通过安全方式来发布。
+ 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

## 安全地共享对象

当发布一个对象时，必须明确说明对象的访问方式。在并发程序中使用和共享对象时，可以使用一些实用的策略。例如：

+ 线程封闭。线程封闭对象只被一个线程拥有。
+ 只读共享。共享的只读对象只能被多个线程访问，不能修改，无需额外的同步。
+ 线程安全类共享。线程安全的类内部实现同步，多个线程只需通过公有接口访问即可。
+ 保护对象。被保护对象只能持有特定锁进行访问。