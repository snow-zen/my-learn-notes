# 实例封闭
#Java #Multithreading 

在使用某一个对象时，如果对象不是线程安全的，我们可以通过封装的方式来实现线程安全。封装简化了线程安全类的实现过程，它提供了一种实例封闭机制。

通过封装与合适的加锁策略可以把原有非线程安全的对象变为线程安全的。将数据封装在对象内部，数据的访问限制在对象的方法上，从而线程访问数据时总能持有正确的锁。

被封闭的对象一定不能超出它们既定的作用域。虽然对象本身不会逸出，但逸出总是开发人员在发布对象时超出了对象既定的作用域。如果一个本该被封闭的对象发布出去，那么也能破坏封闭性，因为让对象逸出作用域就是一个错误。

例如，通过实例封闭来确保线程安全：

```java
public class PersonSet {
    
    private final Set<Object> set = new HashSet<>();

    public synchronized void addObj(Object obj) {
        set.add(obj);
    }

    public synchronized boolean contains(Object obj) {
        return set.contains(obj);
    }
}
```

这些工厂方法通过[[装饰器模式]]将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象上。

当发布封闭对象的迭代器或内部类实例时，可能也会间接的发布被封闭对象，这同样也意味着封闭对象的逸出。

> 封闭机制更易于构造线程安全类，因为当封闭类的状态时，在分析类的线程安全性时无须检查整个程序。

## Java 监视器模式

从线程封闭原则及其逻辑推论可以得出 Java 监视器模式。遵循 Java 监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。

Java 监视器模式仅仅是一种编写代码的约定，它的主要优势就在于它的简单性。对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象状态。

如果客户代码错误地获得了另一个对象的锁，那么可能会产生活跃性问题。此外，要想验证某个公有访问的锁在程序中是否被正确地使用，则需要检查整个程序，而不是单个类。
