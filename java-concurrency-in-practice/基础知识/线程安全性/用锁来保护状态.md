# 用锁来保护状态
#Java #Multithreading 

由于锁能使其保护的代码路径以串行形式访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。

> 只需要遵守这些协议，就可确保状态的一致性。

对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁。一种常见的错误是只有在写入共享变量时才需要使用同步，然而事实并非如此。

> 每个共享和可变的变量都应该只由一个锁保护，从而使维护人员知道是哪一个锁。

常见的加锁约定是：将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码进行同步，使得在该对象上不会发生并发访问。这种情况下对象状态中的所有变量都由对象的内置锁保护起来。然而，这种模式没有任何特殊之处，编译器和运行时都不会有反应。如果修改代码或增加方法时忘记了同步，那么加锁协议将被破坏。

当类的不变性条件涉及多个状态变量时，还有另一个需求：在不变性条件中的每个变量都必须在同一个锁来保护。因此可以在单个原子操作中访问或更新这些变量，从而确保不变性不被破坏。

虽然使用关键字 synchronized 进行加锁可以保证同步，但是过度使用还可能导致活跃性问题或性能问题。