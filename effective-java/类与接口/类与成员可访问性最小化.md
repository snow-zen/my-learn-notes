# 类与成员可访问性最小化
#Java 

判断组件设计得好不好，唯一重要的因素在于它对外部其他组件而言，是否隐藏了其内部数组和其他实现细节。信息隐藏是软件设计的基本原则之一：良好的组件会隐藏所有实现细节，把 API 与实现清晰隔离开来，然后组件之间只通过 API 进行通信，一个模块不需要知道其他模块的内部工作情况。

信息隐藏的好处：
1. 组件之间可以独立开发、测试、优化、使用、理解和测试。
2. 组件可以并行开发，加快系统开发的速度。
3. 减轻维护的负担，可以更快理解组件，并且在调试它们的时候不影响其他组件。
4. 可以有效调节性能，剖析影响性能的组件进一步优化，而不会影响其他组件的正确性。
5. 信息隐藏也降低构建大型系统的风险，即使整个系统不可用，独立组件仍然可能是可用的。

## Java 信息隐藏机制

Java 提供了许多机制来协助信息隐藏。

### 类与接口访问控制

访问控制机制决定了类、接口和属性的可访问性。实体的可访问性是由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符共同决定的。

访问修饰符应尽可能地使每个类或者属性不被外界访问。在保证软件功能一致的同时，尽可能提供最小的访问级别。对于顶层非嵌套的类或接口，只可能有两种访问级别：包级私有和公有的。公有的类或接口，你有责任永远支持它，以保持它们的兼容性。如果是包级私有的，它实际上成了包的实现一部分，而不是该包导出的 API 的一部分，在以后的发行版中，可以对它进行修改、替换和删除，而无需考虑是否影响现有客户端程序。

如果一个顶层类和接口只是在某个类的内部使用，就应该考虑使它成为唯一使用它的类的内部嵌套类，从而降低可访问范围。

> 尽量降低类的可访问性，将它的可访问范围从包中的所有类缩小到使用它的那个类。

### 成员访问级别

成员包含属性、方法、嵌套类和嵌套接口。存在以下访问级别：
+ **私有（private）**，只有声明该成员的顶层类内部才能访问该成员。
+ **包级私有**，声明该成员的包内部的任何类都可以访问该成员。
+ **受保护（protected）**，声明该成员的类和子类可以访问这个成员，并且成员所在包的类也可以访问。
+ **公有（public）**，在任何地方都可以访问。

设计类的公有 API 时，应该把所有其他成员都变为。只有当同一个包内的另一个类真正需要访问一个成员时，你才应该删除 private 修饰符，使成员变成包级私有。公有类的成员从包级私有变为受保护级别时，受保护的成员是类导出 API 一部分，必须永远得到支持。导出类的受保护成员也代表了该类对于某个实现细节的公开承诺。

### 方法覆盖与接口实现对访问级别的影响

如果方法是覆盖了父类中的一个方法，子类中的访问级别就不允许低于父类中的访问级别。如果违反了这条规则，那么当试图编译该子类的时候，编译器就会产生一条错误消息。

当类实现接口时，接口中的所有方法都必须是公开的。

### 测试对访问级别的影响

有时为了便于测试，可能会将公有类的私有成员变为包级私有，这也是可以接受的。但是将访问级别提高到超过它，则就无法接受。

### 公有类属性限制

公有类中的属性绝不能是公有的。如果实例属性是非 final 修饰或者指向一个可变对象的 final 引用，一旦这个属性成为公有，你将放弃以下能力：
1. 放弃对值进行限制的能力。
2. 放弃强制属性不可变的能力。
3. 属性值修改时，失去对其采取任何措施的能力。

即使属性是 final 类型并且引用了不可变对象，但当把属性变成公有时，也就放弃了“切换到一种新的内部数据表示法”的灵活性，该建议同时也适用于静态属性。

> 注意，包含公有属性的类通常不是线程安全的。

### 数组属性限制

长度非零的数组总是可变的，所以让类具有公有的静态 final 数组属性或者返回这种属性的访问方法是错误的。客户端总是可以修改数组内部索引位置所指向元素。

> ⚠️ 注意：许多 IDE 生成的数组属性 getter 方法都会返回指向私有数组属性的引用，这正好会导致这个问题。

解决方案有两种：
1. 返回一个数组对应 List 列表且封装为不可变的。
2. 返回一个数组的拷贝。

### 模块系统访问限制

Java 9 开始，新增两种隐式访问级别，作为模块系统的一部分。模块可以通过其模块中的导出声明显式地导出它的一部分包。模块中未被导出的包在模块之外是不可访问的；模块内部，可访问性不受导出声明的影响。

> 包含在名为 module-info.java 源文件中才能被导出。

未导出的包中公有类的公有属性和受保护的属性都提高了两个隐式访问级别，这是正常的公有和受保护级别在模块内部的对等体。对于这种共享的需求相对罕见，经常通过在包内部重新安排类来解决。

与传统四个主访问级别不同，这两个基于模块的级别主要提供咨询，如果把模块 JAR 文件放在应用程序的类路径下，而不是模块路径下，模块中的包就会恢复其非模块的行为：无论包是否被导出，包中的公有类的所有公有的和受保护的属性将都有正常的可访问性。

> 例外的是 JDK 本身：Java 类库中未导出的包在其模块之外确实是不可访问的。

对于传统的 Java 程序员而言使用模块带来的问题：
1.  将包集中在模块中。
2.  在模块中显式地表明所有的依赖关系，需要重新安排代码结构树。
3.  从模块内部采取特殊的动作调解对于非模块化的包的任何访问。

因此现在说模块将在 JDK 本身之外获得广泛的使用，还为时过早。同时，似乎最好不用它们，除非你的需求非常迫切。