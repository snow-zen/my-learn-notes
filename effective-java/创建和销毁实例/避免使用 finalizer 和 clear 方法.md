# 避免使用 finalize 和 clear 方法
#Java 

finalize 方法通常是不可预测的，也很危险，一般情况下是不需要使用的。使用 finalize 方法可能会导致行为不稳定、性能下降以及可移植性差的问题。在 JDK 9 之后可以使用 clear 方法进行代替，虽然它没有 finalize 方法那么危险，但是它依然是不可预测、运行缓慢，一般情况下也是不要使用的。

使用 finalize 和 clear 方法清除资源存在以下缺点：
1. 不能保证会被及时执行。
2. 实例从创建到不可达，最后被回收，所花费的时间没有限制，可以是任意长的。
3. 如果忽略在执行方法中抛出的未捕获的异常，则该实例的终止过程也会终止。

> 作为清除内存资源的手段，使用 try-catch-finally 方法是更优的选择。

finalize 和 clear 方法在不同 JVM 上的实现会大相径庭，因此在上面所建立的应用程序逻辑也同样会出现不一样的效果。因此永远不要依赖 finalize 或者 clear 方法进行重要状态的更新，因为 Java 语言规范不仅不保证 finalize 或 clear 方法会被及时执行，而且根本就不保证它们会被执行。

同时，在 finalize 方法执行期间未被捕获的异常不会像通常一样会打印异常堆栈，甚至警告都不会被打印。

## 性能问题

相较于 try-catch-finally，使用 finalize 或者 clear 方法清除资源所花费的时间大约慢 50 倍。

## 安全问题

finalize 方法为 **finalize 方法攻击**打开了类的大门。

finalize 方法攻击的思想很简单：如果从构造方法或者序列化对等体（readObject 和 readResovle 方法）中抛出异常，恶意子类的 finalize 方法就可以在构造一部分应该半途夭折的对象上运行。这个 finalize 方法将在一个静态属性中引用该对象，阻止它被垃圾回收。一旦记录到异常的对象，就可以轻松地在这个对象上调用任何原本永远不允许在这里出现的方法。

为了防止非 final 类受到 finalize 方法攻击，要编写一个空的 finalize 方法。

## 正确使用方式

第一种合法用途是，当资源的所有者忘记调用资源的 close 方法释放资源时，finalize 或 clear 方法可以充当“安全网”。虽然这种做法并不能保证资源一定会被回收，但是迟一些释放资源也比永远不释放资源要好。

第二种合法用途与本地对象有关，普通对象通过本地方法委托给一个本地对象。因为本地对象不是一个普通的对象，垃圾回收器并不知道它的存在，在它的对应 Java 对象被回收时，它不会被回收。

> ⚠️ 注意：如果本地对象拥有必须被及时终止的资源，或者性能无法接受，那么类就应该具有一个 close 方法。