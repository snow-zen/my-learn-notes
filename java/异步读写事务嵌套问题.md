# 异步读写事务嵌套问题
#Java

在实际的业务场景中，有时可能会写出事务嵌套的代码，在某个服务完成对应事务操作后，需要通过事件通知等机制异步触发其他服务的功能完成额外功能的事务操作。如果是读事务中嵌套写事务，则没有太大问题；但如果是写事务中嵌套读事务时，则有很大几率出现数据不一致的情况。

> 注意：上述问题场景主要在使用 Spring 框架所提供的方法级别事务注解时，嵌套事务是异步且数据存在依赖的情况下才会发生。

场景如下：

![异步读写事务嵌套](https://my-images-repo.oss-cn-hangzhou.aliyuncs.com/java/%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%86%99%E4%BA%8B%E5%8A%A1%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98.png)

问题在于当写事务在触发异步读事务后，如果写事务未及时的提交，则会出现读事务由于事务的隔离性无法读取到写事务所做的最新变更。通常发生于以下场景：

+ 写事务影响行数多，事务提交时间长。
+ 程序中写事务所在线程的 CPU 时间片耗尽，无法立即完成提交。

## 解决方案

**方案一：调整数据库的事务隔离级别**

由于是因为数据库事务的隔离性所造成读事务未能读取到写事务未提交的操作，因此将数据库的事务隔离级别调整到 `READ UNCOMMITED` 级别则可解决问题。

但是这种方法必定是非常冒险的，它会让数据处于脏读等问题中，数据很可能会出现不一致的情况，因此这种方案所付出的代价过高，是不可取的。

**方案二：放弃嵌套调用**

由于是在写事务内嵌套异步调用所造成的，则可以将调用提取出来，由原来的嵌套调用改为平行调用：

```java
callWriteTranscation();
callReadTranscation();
```

这样就可以保证在写事务完全提交过后，才会触发读取事务，且无需关心调用是否为同步或异步。

这种方法是最稳妥的，无需付出很高的代价，且重构后的代码也符合单一指责原则。
