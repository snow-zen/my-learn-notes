# 封装记录
#Refactoring 

记录型数据结构是多数编程语言的一种常见结构。它们可以直观地组织起存在关联的数据，可以将数据作为有意义的单元传递，而不仅是一堆数据的拼凑。

## 动机

但是简单的记录型结构也是有缺陷的，最恼人的一点是，它强迫我清晰地区分“记录中存储的数据”和“通过计算得到的数据”。

对于可变数据，总是偏爱使用类对象而非记录的原因。对象可以隐藏结构的细节，仅为相关字段提供对应的方法，该对象的用户不必追究存储的细节和计算的过程。同时封装还有利用字段的改名：可以重命名字段，但同时提供新老字段名的访问方法，这样可以渐进地修改调用方，直到替换全部完成。

对于不可变数据，大可直接使用字段，需要做数据变化时增加一个填充步骤即可。重命名记录同样简单，可以复制一个字段并逐步替换引用点。

记录型结构可以有两种类型：一种需要声明合法的字段名字，另一种可以随便用任何字段名字。后者常由语言库本身实现，并通过类的形式提供出来，这些类称为散列、映射、散列映射、字典或关联数组等。这种类结构非常灵活，但一条记录上所持有的字段往往不够直观。若这种记录只是在程序的小范围内使用，那问题不大，但若使用范围变宽，则“数据结构不直观”就会造成更多的困扰。

程序中间常常需要互相传递嵌套的列表或散列映射结构，这些数据结构后续经常需要被序列化成 JSON 或 XML，这样的结构同样值得封装。

## 做法

1. 对持有记录的变量使用[[封装变量]]，将其封装到一个函数中。

> 可以为函数取一个容易搜索的名字。

2. 创建一个类，将记录包装起来，并将记录变量的值替换为该类的一个实例。然后在类上定义一个访问函数，用于返回原始的记录。修改封装变量的函数，令其使用这个访问函数。
3. 测试。
4. 新建一个函数，让它返回该类的对象，而非那条原始的记录。
5. 对于该记录的每处使用点，将原先返回记录的函数调用替换为那个返回实例对象的函数调用。使用对象上的访问函数来获取数据的字段，如果该字段的访问函数还不存在，那就创建一个。每次修改之后运行测试。

> 如果记录比较复杂，例如是个嵌套解构，那么先重点关注客户端对数据的更新操作，对于读取操作可以考虑返回一个数据副本或只读的数据代理。

6. 移除类对原始记录的访问函数，那个容易搜索的返回原始数据的函数也要一并删除。
7. 测试。
8. 如果记录中的字段本身也是复杂结构，考虑对其再次应用[[封装记录]]或[[封装集合]]手法。

