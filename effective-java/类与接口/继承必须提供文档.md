# 继承必须提供文档
#Java 

对于专门为了继承而设计的类，类必须拥有良好的文档说明，否则禁止继承。良好的文档说明必须满足以下要求。

## 文档需要精确描述

首先，类文档必须精确描述覆盖每个方法所带来的影响，同时对于可覆盖方法的使用情况也要描述清楚：
+ 公有方法、包级私有方法以及构造方法都必须说明实现代码中调用了那些可覆盖方法。
+ 可覆盖方法是以什么顺序调用的，每个调用结果又是如何影响后续处理过程的。

> 如果某个方法调用了可覆盖方法，则必须在 Javadoc 中添加 `@implSpec` 标签来对该调用进行描述。

关于程序文档有句格言：好的 API 应该描述它做了什么，而不是描述它怎么工作。对于我们上述的说法实际上是违背了这句格言，但这更多是继承破坏了封装性所带来的不幸后果，而非文档本身所带来的问题，良好的文档更多是对封装性破坏的修补，以便它能够更加安全的被子类化。

## 提供适当的钩子

类必须以精心挑选的受保护方法作为提供适当钩子的形式，以便进入其内部工作中。遗憾地是设计类时并没有什么神奇法制可以供我们使用，所能做到的最佳途径就是努力思考，发挥最好的想象，然后编写一些子类进行测试。

## 编写子类进行测试

对于为了继承而设计的类，唯一的测试就是编写子类。只有亲自尝试编写对应子类时，才会使遗漏所带来的痛苦变得更加明显，才能明确是否遗漏了那些关键受保护成员。

> 经验表明，3 个子类通常就足以测试一个可扩展类。除了父类的程序设计者之外，都需要编写一个或者多个这种子类。

同时，我们需要意识到文档中所描述的自用模式，以及对于其受保护方法和属性所隐含的实现策略，你实际上已经做了永久的承认。这些承诺使得你在后续版本中提高这个类性能或者增加新功能都变得非常困难，甚至不可能。

还要注意的是，因继承而需要的特殊文档会打乱正常的文档信息，正常的文档信息是被设计用来让程序员可以创建该类的实例，并调用类中的方法。

## 继承类的限制

为了允许使用继承，类还必须遵守一些其他的约束规则。

构造方法不能调用可被覆盖的方法，无论是直接调用还是间接调用，因为这会导致程序执行时出现错误的结果或直接失败。但是构造方法调用私有方法、final 方法和静态方法都是安全的，这些都是不可被覆盖的方法。

在设计继承类时，实现 Cloneable 或 Serializable 接口都不是一个很好的主意，这会给子类强制添加一些与功能没有太多关系的负担。如果决定要实现 Cloneable 或 Serializable 接口，则也适用上述规范：无论是 clone 或 readObject 方法都不可直接调用覆盖方法，不管是以直接调用还是间接调用。

最后，如果继承类实现了 Serializable 接口，并且类有一个 readResolve 或 writeReplace 方法，就必须使方法是包级私有的。因为如果方法是私有的，则子类会忽略这两个方法。

## 非继承类被继承的防范

这个问题的最佳解决方案是，对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化。有两种方法可以禁止子类化：
1. 容易的方法是把这个类声明为 final 类型。
2. [[静态工厂方法代替构造方法]]创建实例，构造方法私有化。
3. 可通过[[复合优于继承|复合]]方式来增强原有功能。

如果现有类没有实现任何接口，那么禁止继承可能会给某些程序员带来不便。如果你认为允许从这样的类继承，一种合理的方式是确保这个类永远不会调用它的任何可覆盖方法，并在文档中说明。也可以通过将每个可覆盖方法的代码块移到一个私有“辅助方法”中，并且让每个可覆盖方法调用它的私有辅助方法。这样，覆盖方法时将永远不会影响其他任务。
