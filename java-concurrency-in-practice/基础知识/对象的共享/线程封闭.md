# 线程封闭
#Java #Multithreading 

当访问共享的可变数据时，通常是需要使用同步的。

一种避免使用同步的方式就是不共享数据，即如果只在单线程内访问数据，则就不需要同步。这种技术被称为**线程封闭**，它是实现线程安全的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。

线程封闭的另一种常见应用是 JDBC 的 Connection 对象。由于大多数请求都是由单个线程采用同步的方式来处理，并且在 Connection 对象返回之前，连接池不会再将它分配给其他线程，因此，这种连接管理模式在处理请求时隐含地将 Connection 对象封闭在线程中。

线程封闭是在程序设计中的一个考虑因素，必须在程序中实现。Java 语言以及核心库提供了一些机制来帮助维持线程封闭性，如局部变量和 ThreadLocal 类。但即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。

## Ad-hoc 线程封闭

Ad-hoc 线程封闭是指维护线程封闭性的职责完全由程序实现来承担。但事实上，Ad-hoc 线程封闭非常脆弱，没有任何一种语言特性，例如可见性修饰符和局部变量，能够将对象封闭在目标线程中。因为对线程封闭对象的引用通常都保存在公有变量中。

当决定使用线程封闭技术时，通常是将某个特定的子系统实现为一个单线程子系统。通常情况下，单线程子系统提供的简便性要胜过 Ad-hoc 线程封闭性的脆弱性。[^1]

[^1]: 使用单线程子系统的另一个原因是为了避免死锁，这也是大多数 GUI 框架都是单线程的原因。

在 volatile 变量上存在一种特殊的线程封闭。只要能确保只有单个线程对共享的 volatile 变量执行写入操作，在单线程中写入防止竞态条件的发生并且可见性保证其他线程能够看到最新的值。

> 由于 Ad-hoc 线程封闭技术的脆弱性，因此在程序中尽量少用它。在可能的情况下，应该使用更强的线程封闭技术。

## 栈封闭

栈封闭是一种特殊的线程封闭，在栈封闭中只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程的栈中，并且其他线程无法访问这个栈。

对于基本数据类型的局部变量是无论如何都不会破坏栈封闭性的，因为任何方法都无法获得基本类型的引用，因此 Java 语义确保了基本类型的局部变量始终封闭在变量中。

对于引用对象的局部变量而言，需要多做一些工作以确保被引用的对象不会逸出。

如果在线程内部上下文中使用非线程安全的对象，那么该对象仍然是线程安全的。然而需要注意的是，只有编写代码的开发人员才知道那些对象需要被封闭到执行线程中，以及被封闭的对象是否是线程安全的。如果没有明确说明，那么后续维护人员很容易错误地使对象逸出。

## ThreadLocal 类

使用 ThreadLocal 是维持线程封闭性的一种更规范方法，这个类能使线程中的某个值与保存值的对象关联起来。在每个使用该变量的线程中都有一份独立的副本。

ThreadLocal 对象通常用于防止对可变的单实例变量或全局变量进行共享。在原理上，它是在 Thread 实例中 Map 属性中作为键值对中的 key 进行存储。这样的设计可以在线程终止时，与当前 ThreadLocal 相关的值都会被垃圾回收。

![ThreadLocal 底层设计](https://gitee.com/snow-zen/my-images-repo/raw/master/java-concurrency-in-practice/ThreadLocal%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1.png)

> 注意：开发人员经常滥用ThreadLocal，它类似于全局变量。它能够降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。

