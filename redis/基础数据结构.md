# 基础数据结构
#Redis

Redis 作为一款内存型的数据结构存储中间件，它提供了丰富的数据结构用于数据存储。

## String

String 是 Redis 最基本的值类型，同时它也是二进制安全的。每个字符串值的最大长度为 512 Mb。[^1]

[^1]: 字符串长度使用无符号 4 字节的 int 类型表示，最大位数为 $2^{32}$。

> 二进制安全意味着存入时字符串二进制内容与取出是字符串二进制内容是相同的。

由于 Redis String 的二进制安全特性，因此它存在许多衍生类型的操作命令集。例如：

+ 用作数字类型的原子计数器：`INCR`、`DECR`、`INCRBY`。
+ 用作二进制序列的二进制操作：`GITBIT`、`SETBIT`。

## List

List 是使用链表实现的，因此在 List 的头部和尾部插入或删除元素时，它的时间复杂度为 $O(1)$。而如果查询列表中间某个元素时，则时间复杂度会上升到 $O(N)$。

由于 Redis 所有操作都是原子性的，并且 List 还支持阻塞获取元素命令。因此 Redis 列表还可以当作简易的生产者 - 消费者队列来使用。

> List 的最大长度为 $2^{32}-1$ 个元素。[^2]

[^2]: 即列表的长度使用 4 字节的 int 类型来表示。

## Set

Set 是 String 的无序集合，可以在时间复杂度为 $O(1)$ 的情况下完成插入、删除和检查元素是否存在，同时 Set 具备不允许重复元素的特性。

Set 还支持两个集合之间的相关操作，例如交集、并集和差集。

> Set 的最大长度为 $2^{32}-1$ 个元素。

## Hash

Hash 是一个字符串字段与字符串值之间的 Map，因此它是用于表示对象信息的完美数据结构。

> 每个 Hash 最多可以存储 $2^{32}-1$ 个键值对。

## ZSet

ZSet 与 Set 类似，唯一的差异是它是有序的集合。ZSet 中的每个元素都会关联一个分数，并通过分数进行元素排序。

ZSet 是使用跳表实现的一种数据结构，因此它可以在时间复杂度为 $O(logN)$ 的情况下完成添加、删除和更新元素。同时由于元素是根据分数进行顺序存储的，因此还可以通过分数和排名以非常快速的方式获取范围内的数据。

## BitMap

BitMap 并不是实际的数据类型，而是在 String 类型上定义的一组面向位的操作。由于字符串的最大长度为 512 Mb，即最多 $2^{32}$ 位。

BitMap 的最大优势之一是它们在存储信息时通常可以极大的节省内存。

## HyperLogLog

HyperLogLog 是一种概率数据结构，用于对独特事务进行计数。通常的计算需要使用与计算的数量成比例的内存量，因为需要记住过去已经看到的元素以避免多次计算它们。

然而，有一组算法可以用内存来换取精度：以一个带有标准误差的估计度量结束，在 Redis 实现的情况下，这个误差可以达到 1%。该算法的神奇之处在于不需要使用与计数量成正比的内存量，而是可以使用恒定量的内存！最坏情况下为 12k 字节。

Redis 中的 HLL，虽然在技术是一种不同的数据结构，但被编码为 Redis 字符串，因此可以调用 GET 以序列化，并通过 SET 将其发序列化回服务器。

