# 一致性保证
#ZooKeeper 

ZooKeeper 是一种高性能、可扩展的服务。读取和写入操作都被设计为快速，这样做的原因是，在读取的情况下，ZooKeeper 可以服务较旧的数据，这是由于 ZooKeeper 的一致性保证：

+ **顺序一致性**：客户端的更改将按照它们发送的顺序应用。
+ **原子性**：只有全部更新成果或者全部更新失败。
+ **单一系统映像**：不管连接到哪个服务器，客户端将看到相同的服务视图。即使客户端故障转移到具有相同会话的不同服务器，客户端也永远不会看到系统的旧视图。
+ **可靠性**：一旦更新被应用，更新结果从那时起持续存在，直到客户端覆盖该更新。这种保证有两个推论：
	1. 如果客户端获得成功的返回码，则更新将被应用。在某些故障上，客户端将不知道更新是否已应用。我们采取措施尽量减少失败，但只有成功的返回代码才会提供保证。
	2. 客户端通过读取或者更新成功看到的任何变更，在从服务器故障恢复中都永远不会回滚。
+ **及时性**：保证系统客户端在一定时间范围（大约几十秒）内即可获取最新的数据，客户端将在此范围内看到系统更改，或者客户端将检测到服务中断。

使用这些一致性保证可以很容易地在 ZooKeeper 客户端构建更高级别的功能，例如 leader 选举、屏障、队列和读写撤销锁。

## 错误认知：同时一致的跨客户端视图

有时开发人员会错误地假设 ZooKeeper 实际上没有做出的另一种保证：**同时一致的跨客户端视图**。ZooKeeper 不保证在每个实例中，两个不同客户端将具有相同的 ZooKeeper 数据视图。

由于网络延迟等因素，一个客户端可能会在另一个客户端收到更新通知之前执行更新。如果客户端 A 将 znode 节点 /a 值从 0 设置为 1，然后客户端 B 读取 znode 节点 /a，则取决于网络和连接到的服务器，读取到的值可能为 0 或者 1。

如果客户端 A 和客户端 B 读取相同的值很重要，客户端 B 应该在执行读取之前从 API 方法中调用 sync 方法。因此，ZooKeeper 本身并不能保证更改在所有服务器之间同步发售，但 ZooKeeper 可用于构建提供有用的客户端同步的更高级功能。