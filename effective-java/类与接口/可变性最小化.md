# 可变性最小化
#Java 

不可变类是指所有实例都不可改变的类，实例中的所有属性都必须在创建该实例时就提供，并在对象的整个生命周期内固定不变。不可变类比可变类更加易于设计、实现和使用，它们不容易出错且更加安全。

成为不可变类，需要满足以下五条要求：
1. 不提供任何会改变对象状态的方法。
2. 类不会被扩展。
3. 类中所有属性都是 final 类型。
4. 类中所有属性都是私有的。
5. 确保对于任何可变组件的互斥访问。即客户端代码无法获取实例中属性引用，实例初始化也不使用客户端实例进行属性初始化。

## 函数的方法

大多数不可变类提供的方法并不会对实例进行修改，而是创建一个新实例返回。例如，LocalDataTime、BigDecimal 等。这些方法返回一个函数结果，这些函数对操作数进行运算但并不修改它。

## 不可变类优点

### 简单

不可变类比较简单，对应实例从创建开始只会存在一种状态。

如果能够确保所有的构造方法都建立在这个类的约束关系，就可以确保这些约束关系在整个生命周期内永远不会发生改变，并且开发者和客户端都无须再做额外的工作来维护约束关系。

另一方面，可变类有任意复杂的状态空间。如果文档中没有为设值方法所执行状态提供精确描述，要可靠地使用可变类是非常困难的，甚至是不可能的。

### 线程安全

不可变实例本质上是线程安全的。当多个线程访问不可变实例时，它们不会遭到破坏，因此不可变对象还可以自由地共享。

对于一些被频繁使用的实例，可以提供静态工厂把实例缓存起来，当被请求时无须再次创建新的实例。

### 无需保护性拷贝

不可变实例共享时无需保护性拷贝。由于拷贝实例始终等于原实例，因此给不可变类提供 clone 方法或者拷贝构造方法是没有意义的。

### 可共享内部信息

不仅可以共享不可变实例，甚至还可以共享它们的内部信息。例如，BigInteger 类内部使用一个 int 数值表示符号，一个 int 数组表示数值。当调用 negate 方法返回一个新 BigInteger 实例时，其中数值是一样的，符号则是相反的。

### 为其他对象提供大量组件

不可变实例经常作为映射键或者集合元素。一旦不可变实例进入到映射或者集合中时，尽管这破坏了映射或集合的不可变约束，但是也不用担心它们的值会发生变化。

### 原子性

因为不可变实例状态不可变，因此不存在临时的中间状态。

## 不可变实例缺点

不可变实例中不同的值都需要生成一个实例。创建这些实例的代价可能很高，特别是大型实例。

如果执行的是一个多步骤操作，并且每个步骤都会产生一个新对象，则可以把多个步骤操作作为基础操作提供，不可变实例就无需在每个步骤都创建实例。例如，BigInteger 有个包级私有可变“配套类”，它的用途是加速诸如“模指数”这样的多步骤操作。

## 代替不可变类

除了将类声明为 final 类型外，还可以将类中所有构造方法声明为私有或者包级私有，并添加[[静态工厂方法代替构造方法|公有静态工厂来代替公有构造器]]。

实际上，对于不可变类所需满足的规则比真正的要求更强硬一点，为了提高性能可以有所放松。事实上应该是这样的：没有一个方法能够对实例的状态产生外部可见的改变。因此许多不可变类拥有一个或者多个非 final 的属性用于缓存衍生数据。

## 不可变类序列化

如果需要让不可变类实现 Serializable 接口，并且它包含一个或多个指向可变对象的属性，就必须提供一个显式的 readObject 方法或者 readResolve 方法，或者使用 ObjectOutputStream.writeUnshared 和 ObjectInputStream.readUnshared 方法。

> 即使默认的序列化形式是可以接受的，也应该如此。否则，攻击者可能从不可变类创建可变的实例。

## 不可变类设计建议

除非有很好的理由要让类成为可变的类，否则它就应该是不可变的。

然而，对于部分类而言，其不可变性可能是不切实际的。如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性。除非有令人信服的理由使属性变成非 final 类型，否则要使每个属性都是 private final 类型。

构造方法应该建立完全的初始化对象，并建立起所有的约束关系。不要在构造方法或静态工厂之外再提供公有的初始化方法，除非有令人信服的理由必须这么做。