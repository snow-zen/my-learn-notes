# 依恋情结
#Refactoring 

所谓模块化，就是力求将代码划分区域，最大化区域内部的交互、最小化跨区域的交互。有时会发现，函数和另一个模块的函数或者数据交流格外频繁，远胜于自己所在模块内部的交流，这就是依恋情结的典型情况。

解决方法显而易见：这个函数想跟这些数据待在一起，此时就用[[搬移函数]]把它移过去。有时，函数中只有一部分受依恋之苦，这时候应该使用[[提炼函数]]把这一部分提炼到独立的函数中，再搬移到合适的模块中。

有时可能没有那么简单。一个函数往往用到几个模块的功能。此时需要判断哪个模块拥有此函数使用的数据最多，然后将其与那些数据摆放到一起。如果先以[[提炼函数]]将函数分解为数个较小的函数并分别置放于不同的地点，上述步骤则更容易完成。

例外的是，有几个复杂精巧的模式破坏了规则。如[[策略模式]]、[[访问者模式]]和 Kent Beck 的 Self Delegation 模式，这些模式都是对抗发散式变化的坏味道。最根本的原则是：将总是一起变化的东西放在一起。数据和引用数据的行为总是一起变化的，但也存在例外。如果例外出现，保持变化只在一处发生。策略模式和访问者模式使得可以轻松修改函数的行为，因为它们将少量需要被覆写的行为隔离出来。