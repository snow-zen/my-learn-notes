# 线程安全性概述
#Java #Multithreading

构建稳健并发程序时，必须正确地使用线程和锁。但这些终归只是机制，编写线程安全代码其核心在于对状态访问操作进行管理，特别是对**共享**和**可变**的状态的访问。

从非正式的意义来说，对象的状态是指存储在状态变量（例如实例或静态属性）中的数据。对象状态可能包括其他依赖对象的属性。例如，HashMap 的状态不仅存储在 HashMap 对象本身，还存储在许多 Map.Entry 对象中。在对象状态中包含了任何可能影响其外部可见行为的数据。

“共享”意味着变量可被多个线程同时访问，“可变”意味着变量的值在其生命周期内可以变化。一个对象是否需要线程安全，取决于它是否被多个线程访问。要使得对象是线程安全的，需要采用同步机制来协同对象可变状态的访问。

> 注意：如果对可变对象的访问无法实现协同，可能导致数据破坏以及其他不该出现的结果。


当多个线程同时访问同一对象并且其中一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。如果没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：

+ 不在线程之间共享该状态变量。
+ 将状态变量修改为不可变的变量。
+ 在访问状态变量时使用同步。

如果在程序设计时没有考虑并发访问问题，那么在采用上述方法时可能需要对设计进行重大修改，因此，要修复这个问题可谓是知易行难。如果从一开始就设计一个线程安全的类，那么比在以后再将这个类修改为线程安全的类要容易的多。

> 当设计线程安全的类时，良好的面向对象技术、不可修改性，以及明晰的不变性规范都能起到一定的帮助作用。

编写并发程序时，一种正确的编程方式是：首先使代码正确运行，然后再提高代码的速度。即便如此，最好也在性能测试和应用需求告诉你需要提高性能，以及测量结果表明这种优化在实际环境中能带来性能提示时，才进行优化。[^1]

[^1]: 在编写并发代码时，应该始终遵循这个原则。由于并发错误是非常难以重现和调优的，因此如果只是在很少执行的代码路径上获得性能提升，那么很可能被程序运行时存在的失败风险而抵消。

> 注意：打破封装将更加难以实现线程安全，而且会导致线程的安全性更加脆弱。这不仅增加了开发成本和风险，而且也增加了维护的成本和风险。

## 线程安全性

在线程安全性的定义中，最核心的概念就是正确性。如果对线程安全性的定义是模糊的，那么就是因为缺乏对正确性的清晰定义。

正确性的含义是，某个类的行为与其规范完全一致。在良好的规范中通常会定义各种**不变性条件**来约束对象的状态，以及定义后各种**后验条件**来描述对象操作的结果。

我们可以通过将单线程的正确性近似定义为“所见即所得”。在对正确性给出一个较为清晰的定义后，就可以定义线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

对于在单线程中都不是正确的程序，那么它也肯定不是线程安全的。如果正确实现对象，那么在任何操作中都不会违背不变性条件或后验条件。在线程安全类的对象实例上执行任何串行或并行操作都不会使对象处于无效状态。

> 线程安全类中封装了必要的同步机制，因此客户端无需进一步采取同步措施。

另外，线程访问无状态对象的行为并不会影响到其他线程中操作的正确性，因此无状态对象是线程安全的。




