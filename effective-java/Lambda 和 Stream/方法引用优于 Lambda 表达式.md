# 方法引用优于 Lambda 表达式
#Java 

相比于匿名类，Lambda 的主要优势在于足够简洁，但 Java 还提供了更加简洁的函数对象表示方法：**方法引用**。常规的方法引用是静态方法引用，但需要保证被引用的方法与函数对象具有相同的参数。

例如，常规 Lambda 表达式使用：

```java
map.merge(key, 1, (count, incr) -> count + incr);
```

而如果将其改为方法引用，则变为：

```java
map.merge(key, 1, Integer::sum);
```

当被方法所携带的参数越多时，方法引用所能消除的样板代码就越多。但有时 Lambda 表达式所携带的参数名称可以提供非常有用的文档信息，这使得 Lambda 表达式代码相较于方法引用可读性更强，并且更易于维护。

> 代码的可读性和简洁总是相互对立。

方法引用可以作为 Lambda 的一种代替，但还有另一种选择：从 Lambda 中提取代码，放到新的方法中，该这个方法起个有意义的名字并用方法的引用代替 Lambda。

许多方法引用都指向静态方法，但其中有 4 种没有这么做。其中两种是有限制和无限制的实例方法引用：
+ 有限制的引用中，接收对象是在方法引用中指定的，本质上类似于静态引用。
+ 无限制的引用中，接收对象是在运用函数对象时，通过在该方法的声明函数前额外添加一个参数来指定，通常在流管道中作为映射或过滤函数。

最后还有两种构造器引用，分别针对类和数组。

方法引用类型以及示例：

| 方法引用类型 | 范例                   | Lambda 表达式                                      |
| ------------ |:---------------------- | -------------------------------------------------- |
| 静态         | Integer::parseInt      | str -> Integer.parseInt(str)                       |
| 有限制       | Instant.now()::isAfter | Instant then = Instant.now(); t -> then.isAfter(t) |
| 无限制       | String::toLowerCase    | str → str.toLowerCase()                            |
| 类构造器     | TreeMap<K, V>::new     | () -> new TreeMap<K, V>                            |
| 数组构造器   | int[]::new             | len -> new int[len]                                |


总之，只要方法引用更加简洁、清晰，就用方法引用。如果方法引用并不简洁，就坚持使用 Lambda 表达式。