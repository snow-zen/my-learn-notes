# 所有权
#Rust 

所有权是 Rust 的核心功能之一。

所有程序都必须管理其运行时使用的计算机内存。一些语言中具有 GC 内存回收机制，在程序运行期间不断寻找不再使用的内存进行回收；另一些语言中，程序员必须亲自分配和释放内存。而 Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译期间会根据一系列的规则进行检查。如果违反规则，程序则编译不通过。

> 运行时，所有权系统的任何功能都不会减慢程序。

## 所有权规则

1. Rust 中所有值都有一个被称为所有者的变量。
2. 值在任意时刻有且只有一个所有者。
3. 当所有者变量离开作用域时，对应的值就会被丢弃。

## 变量作用域

作用域是一个项（item）在程序中有效的范围。变量从声明开始到当前作用域结束前都是有效的，当变量离开作用域时，Rust 会调用一个特殊的函数 drop 释放变量值所占用的内存。例如：

```rust
{
  let s = String::from("test"); // 变量开始有效
} // 变量离开作用域，自动调用 drop 函数
```

> 注意：在 C++ 中，这种项在生命周期结束时释放资源模式有时被称为**资源获取即初始化**（RAII，Resource Acquisition Is Initialization）。

## 变量与数据

在 Rust 中对于变量的赋值存在两种行为：移动和克隆。

### 移动

例如，将字符串 s1 赋值给 s2：

```rust
let s1 = String::from("hello");
let s2 = s1;
```

在其他语言中，一般认为 s2 是对 s1 引用的复制。而在 Rust 中是对指针的移动，原有的 s1 不再有效。

![指针移动.png](https://my-images-repo.oss-cn-hangzhou.aliyuncs.com/rust/%E6%8C%87%E9%92%88%E7%A7%BB%E5%8A%A8.png)

如果是使用复制机制，当变量 s1 和 s2 离开作用域时，Rust 会清理这两个变量所指向的内存。而 s1 和 s2 所指向的是相同内存，这是一个称为二次释放的错误，属于内存安全性 bug 之一。两次释放相同位置内存会导致内存污染，可能会导致潜在的安全漏洞。

而使用移动机制，Rust 不需要为无效的 s1 清理任何东西，只需要对 s2 进行清理工作即可。这种方式避免了二次释放的错误产生，同时如果在移动后继续使用 s1 则会产生编译错误：

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}", s1); // 编译错误
```

另外，这里还隐含了一个设计选择：Rust 永远不会自动创建数据的 “深拷贝”。因此，任何自动进行的复制可以被认为对运行时性能影响较小。

### 复制

如果确实需要深度复制堆上的数据，而不仅仅在栈上的数据时，可以使用 clone 通用函数。

另外，像整形之类在编译时已知大小的类型被整个存储在栈上，它们在栈上进行复制是非常快速的。Rust 存在 Copy trait 的特殊注解，可以用在类似整形这样的类型上。实现了 Copy trait 的类型，在旧变量将其赋值给新变量时，旧变量依旧可用。

> 注意：Rust 不允许自身或部分实现了 Drop trait 的类型使用 Copy trait，否则就会出现编译错误。因为 Drop trait 主要用于复杂结构类型，手动定义其内存释放规则，这种类型一般无法简单的在栈上完成复制。

默认 Rust 中，任何一组简单的标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 类型。例如：

+ 所有的整数类型，比如 `i32`。
+ 布尔类型 `bool`。
+ 所有浮点数类型，比如 `f64`。
+ 字符类型 `char`。
+ 当且仅当其包含的类型都实现 Copy 的元组，比如 `(i32, i32)`。

## 所有权与函数

将值传递给给函数在语义上与变量赋值相似。当值被传递给函数时，值对应的作用域也发生了变化，后续代码无法再继续使用该值：

```rust
fn main() {
  let s = String::from("h");
  test(s); // s 的所有权移入 test 方法

  // 无法使用 s 变量，否则编译错误
} // 变量 s 被移走，无需操作

fn test(s: String) { // s 进入作用域
  println!("{}", s);
} // s 离开作用域，被释放
```

当函数存在返回值时，函数调用完成后返回值的所有权会转移到调用方：

```rust
fn main() {
  let s = String::from("s");
  let s_len = len(s);
  
  println!("{}", s_len);
}

fn len(s: String) -> usize {
  s.len()
}
```