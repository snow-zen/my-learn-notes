# JVM 内存结构
#Java #JVM

JVM 内存结构又称“运行时数据区域”，JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁时间。

根据《Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域：

![运行时数据区域](https://gitee.com/snow-zen/my-images-repo/raw/master/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)

其中的方法区和堆是在整个程序中共享的数据区，随着程序的启动而存在。而虚拟机栈、本地方法栈和程序计数器是每个线程独有的数据区，随着线程的启动而创建，并在线程关闭时销毁。

## 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

JVM 工作时，字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令，从而控制程序的分支、循环、跳转、异常处理等基础功能。

## 虚拟机栈

虚拟机栈（VM Stack）描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。

每个方法被调用直至完毕的过程，就对应一个栈帧在虚拟机中从入栈到出栈的过程。

## 本地方法栈

本地方法栈（Native Method Stack）的作用与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则是为虚拟机所使用到的本地方法服务。

## 堆

对于 Java 应用程序来说，堆（Heap）是虚拟机所管理的内存中最大的一块。堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。堆的唯一目的就是存放对象实例，Java 内“几乎”所有的对象实例都在这里分配内存。

根据《Java 虚拟机规范》的规定，堆可以处于物理上不连续性的内存空间，但在逻辑上它应该被视为连续的，这点就像用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。

堆的大小不是固定的，可以通过参数 `-Xmx` 和 `-Xms` 来调整。当堆用尽指定内存时，虚拟机将会抛出 OutOfMemoryError 异常。

## 方法区

方法区（Method Area）和堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

在 JDK 8 以前，所谓“永久代”仅仅是当时的 HotSpot 虚拟机设计团队选择把收集器的分代设计扩展到方法区，或者说使用永久代来实现方法区。使得 HotSpot 的垃圾收集器可以像管理堆一样管理方法区这部分内存。

使用永久代这一设计并不是一个好主意，这种设计导致 Java 应用程序更容易遇到内存溢出的问题[^1]，而且极少数方法（例如 String::intern）会因为永久代的原因而导致不同虚拟机下有不同的表现。因此，在 JDK 6 时 HotSpot 开发团队就有放弃永久代，逐步改为采用本地内存来实现方法区的计划。到了 JDK 7 的 HotSpot 就已经把原本放在永久代的字符串常量池、静态变量移出，而到了 JDK 8，终于完全废弃了永久代的概念，改为在本地内存中实现的元空间来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中。

[^1]: 永久代可通过 -XX:MaxPermSize 设置上限，即时没有设置，在 32 位系统中也会收到 4 GB 内存限制。

《Java 虚拟机规范》对方法区的约束是非常宽松的，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。因此，垃圾收集在这个区域是比较少见的，但并非不存在。

这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难以令人满意的，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。

根据《Java 虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError 异常。

