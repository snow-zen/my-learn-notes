# 以委托取代子类
#Refactoring 

如果一个对象的行为有明显的类别之分，继承是很自然的表达方式。

## 动机

通常可以把共有的数据和行为放在父类中，每个子类根据需要覆写部分特性。

但是继承也有其短板。最明显的是，导致行为不同的原因可能有很多，但继承只能处理一个方向上的变化。例如，“人”的行为根据“年龄段”不同，并且根据“收入水平”不同。如果使用继承，子类只能是“年轻人”和“老人”，或者“穷人”和“富人”，但不能同时采用两种继承方式。

更大的问题在于，继承给类提供了非常紧密的关系。在父类中做出的任何修改，都有可能破坏子类，所以必须非常小心，并且需要充分理解子类如何从父类中派生的。

上述的两个问题都可以使用委托来进行解决。对于不同的变化原因可以委托给不同的类。委托是对象之间常规的关系。与继承关系相比，使用委托关系时接口更加清晰、耦合更少。因此，继承关系遇到问题时运用以委托取代子类是常见的情况。

## 做法

1. 如果构造函数有多个调用者，首先用[[以工厂函数取代构造函数]]把构造函数包装起来。
2. 创建一个空的委托类，这个类的构造函数应该接受所有子类特有的数据项，且经常以参数的形式接受一个指回父类的引用。
3. 在父类中添加一个字段，用于安放委托对象。
4. 修改子类的创建逻辑，使其初始化上述委托字段，放入一个委托对象的实例。

> 这一步可以在工厂函数中完成，也可以在构造函数中完成。

5. 选择一个子类中的函数，将其移入委托类。
6. 使用[[搬移函数]]手法搬移上述函数，不要删除源类中的委托代码。

> 如果这个方法用到的其他元素也应该被移入委托对象，就把它们一并搬移。如果它用到的元素应该留在父类中，就在委托对象中添加一个字段，令其指向父类的实例。

7. 如果被搬移的源函数还在子类之外被调用，就把源类中的委托代码从子类移到父类，并在委托代码之前加上卫语句，检查委托对象存在。如果子类之外已经没有其他调用者，就用[[移除死代码]]去掉已经没人使用的委托代码。

> 如果有多个委托类，并且其中的代码出现了重复，就使用[[提炼超类]]消除重复。此时如果默认行为已经被移入委托类的父类就不再需要卫语句。

8. 测试。
9. 重复上述过程，直到子类中所有函数都搬到委托类中。
10. 找到所有调用子类构造函数的地方，逐一将其改为使用父类的构造函数。
11. 测试。
12. 运用[[移除死代码]]去掉子类。