# 私有构造方法或者枚举强化单例属性
#Java

[[单例模式]]是 23 种设计模式之一。该模式下程序中只会存在类的唯一实例。在实践中，由于程序只能存在唯一实例，这使得类的测试变得非常困难，因为不能给单例替换或者模拟实现。

## 公有静态属性

实现单例的第一种方式是公有静态属性，属性在类加载时就进行初始化操作：

```java
public class Elvis {

    private Elvis() {
    }

    public static final Elvis INSTANCE = new Elvis();
}
```

实现中类的私有构造方法只会被调用一次，用于初始化 `INSTANCE` 变量。

> 实现中通过私有化构造方法保证类实例在全局唯一，但是对于某些通过反射创建实例的客户端而言依旧能够被调用。因此为了保证单例的特性不会被破坏，可以在第二次调用时抛出异常进行防止。

## 公有静态工厂方法

实现单例的第二种方式是公有静态工厂方法，通过一个公有静态工厂方法提供唯一实例的访问途径：

```java
public class Elvis {

    private Elvis() {
    }

    private static final Elvis INSTANCE = new Elvis();

    public static Elvis getInstance() {
        return INSTANCE;
    }
}
```

相较于[[#公有静态属性]]，公有静态工厂方法存在以下优势：
1. 方法名可以清楚地表达类的单例属性。
2. 通过方法访问更加灵活，方法实现很容易改变。
3. 当程序需要时，可以使用泛型提供一个泛型工厂方法。
4. 在 JDK 8 中，可以通过方法引用的方式进行调用。

> 与[[#公有静态属性]]类似，它也存在客户端反射创建的问题，处理方案也保持一致。

## 单例序列化问题

当单例类需要变为可序列化时，仅仅实现 `Serializable` 接口是远远不够的。

为了保证单例特性不会被破坏，必须保证实例的所有属性都使用 `transient` 修饰，并且提供一个 `readResolve` 方法。否则在每次反序列化时，都会创建一个新的实例：

```java
private Object readResolve() {
    return INSTANCE;
}
```

## 枚举类型

实现单例的第三种方式是枚举类型。例如，包含单个元素的枚举类型：

```java
public enum Elvis {
    INSTANCE;
}
```

这种方式在功能上与[[#公有静态属性]]相似，但在语法上更加简洁，同时枚举又自带序列化机制，绝对防止多次实例化。单个元素的枚举类经常成为实现单例的最佳方式，虽然这种方式目前还没有被广泛采纳。

> ⚠️ 注意：如果单例类需要扩展一个父类时，则无法使用枚举来实现单例模式。