# 类加载器
#Java #JVM 

Java 虚拟机设计团队有意把类加载阶段中的 “通过一个类的全限定名来获取描述该类的二进制字节流” 这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为 “类加载器”（Class Loader）。

## 类与类加载器

类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远超类加载阶段。

对于任意一个类，都必须由加载它的类加载器和类本身一起共同确立其在 Java 虚拟机中的唯一性，每个类加载器都有一个独立的类名称空间。通俗一点说：比较两个类是否 “相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不同。

> 这里指的 “相等”，包括代表类的 Class 对象的 equals 方法、isAssignableFrom 方法、isInstance 方法的返回结果，同时也包括使用 instanceof 关键字做对象所属关系判定等情况。

## 双亲委派模型

站在 Java 虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器由 C++ 实现，是虚拟机自身的一部分；另一种是其他所有类加载器，由 Java 语言实现，独立存在于虚拟机外部，并且全部继承于抽象类 java.lang.ClassLoader。

站在 Java 开发人员的角度来看，则更加细致一些。自 JDK 1.2 后，Java 一直保持三层类加载器、双亲委派的类加载架构，尽管这套架构在 Java 模块化系统出现后有了一些调整变动，但依然未改变其主体结构。

**启动类加载器（Bootstrap Class Loader）**

这个类加载器负责加载存放在 `<Java_HOME>\lib` 目录，或者被 -Xbootclasspath 参数所指定的路径中存放的，而且是 Java 虚拟机能够识别的类库加载到虚拟机的内存中。

启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那就直接使用 null 代替即可。

**扩展类加载器（Extension Class Loader）**

这个类加载器是在类 sun.misc.Launcher$ExtClassLoader 中以 Java 代码的形式出现的。它负责加载 `<JAVA_HOME>\lib\ext`，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库。

这是 Java 的一种扩展机制，JDK 的开发团队允许用户将具有通用性的类库放置在 ext 目录里以扩展 Java SE 的功能。

> 在 JDK 9 之后，这种扩展机制被模块化带来的天然的扩展能力所取代。

由于扩展类加载器是由 Java 代码实现的，开发者可以直接在程序中使用扩展类加载器来加载 Class 文件。

**应用程序类加载器（Application Class Loader）**

这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。由于应用程序类加载器是 ClassLoader 类中的 getSystemClassLoader 方法的返回值，所以有些场合中也称它为 “系统类加载器”。

它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

![类加载器双亲委派模型](https://my-images-repo.oss-cn-hangzhou.aliyuncs.com/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png)

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承的关系实现的，而是通常使用组合关系来复用父加载器的代码。

> 类加载器的双亲委派模型在 JDK 1.2 时被引入，并被广泛用于此后几乎所有的 Java 程序中，但它并不是一个具有强制性约束力的模型，而是 Java 设计者们推荐给开发者的一种类加载器实现的最佳实践。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成，每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器无法完成这个加载请求时，子加载器才会尝试自己去完成加载。

使用双亲委派模型组织类加载器之间关系的好处就是：Java 中的类随着它的类加载器一起具备一种带有优先级的层级关系。如果没有使用双亲委派模型，都由各个类加载器自行去加载，如果用户自己编写了一个名为 java.lang.Object 的类，则系统中就会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无从保证。

## 破坏双亲委派模型

由于双亲委派模型并不是一个具有强制性约束的模型。虽然在 Java 中大部分类加载器都遵循这个模型，但是也有例外的情况。

**双亲委派模型引入时破坏**

由于双亲委派模型是在 JDK 1.2 时才被引入的，但是类加载器的概念和抽象类 java.lang.ClassLoader 则是在 Java 的第一个版本就已经存在了。因此在面对已经存在的用户自定义类加载器的代码，Java 设计者引入双亲委派模型时不得不做出妥协。

为了兼容已有代码，无法再以技术手段避免 loadClass 方法被子类覆盖的可能性，只能在 1.2 之后的 java.lang.ClassLoader 中添加一个新的 protected findClass 方法，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass 中编写代码。

**模型自身缺陷导致的破坏**

双亲委派模型很好的解决了各个类加载器协作时基础类型的一致性问题，但如果出现基础类型要回调用户代码则无法解决。

一个典型的例子是 JNDI 在对资源进行查找和管理时，JNDI 的代码是由启动类加载器来完成加载的，但是指定的资源类是有其他厂商实现并部署在应用程序的 ClassPath 下，因此启动类加载器绝不认识、加载这些类。

为了解决这个问题，Java 的设计团队只好引入一个不太优雅的设计：线程上下文加载器。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader 方法设置，如果创建线程时未设置，则从父线程中继承，如果应用程序的全局范围内都没有设置，则默认是应用程序类加载器。

通过线程上下文加载器，JNDI 服务就可以使用它去加载所需要的 SPI 实现类，这是一种父类加载器去请求子类加载器去完成类加载的行为，这种行为实际上打通了双亲委派模型的层次结构来逆向使用类加载器，基本违背了双亲委派模型的一般性原则。

而为了消除这种不优雅的设计，在 JDK 6 时，JDK 提供了 java.util.ServiceLoader 类，以 META-INF/services 中的配置信息，辅以责任链模式，才算是给 SPI 的加载提供一种相对合理的解决方案。

> 在 JDBC 4.0 之后，其依赖包默认携带 META-INF/services 配置信息。

**代码热替换导致的破坏**

OSGi 实现模块化热部署，每个模块（称为 Bundle）都有一个自己的类加载器，当需要更好一个 Bundle 时，会连同对应的类加载器一起被替换掉以实现代码的热替换。

在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：

1. 将以 java.* 开头的类，委托给父加载器加载。
2. 否则，将委派列表名单内的类，委托给父加载器加载。
3. 否则，将 Import 列表中的类，委派给 Export 这个类的类加载器加载。
4. 否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。
5. 否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委托给 Fragment Bundle 的类加载器加载。
6. 否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。
7. 否则，类查找失败。

查询顺序中只有开头两点符合双亲委派模型的原则，其他都是在平级的类加载器中进行。
