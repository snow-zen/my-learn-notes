# 处理非正常的线程终止
#Java #Multithreading 

当线程发生故障时，它可能会在控制台输出堆栈消息，但大多数时候很少人会去观察控制台，线程故障很容易被人遗漏。因此，我们可以监测并防止程序中“遗漏”的方法。

**导致线程提前死亡的主要原因是 RunntimeException**。由于这些错误可能是由于编码错误导致的。由于它通常不会被捕获，因此不会在调用栈中逐层传递，而是默认在控制台中输出堆栈信息。

这些提前退出的线程所造成的影响取决于线程在应用程序中的作用而定。

**任何代码都有可能抛出一个 RunntimeException**。每当调用另一个方法时，都要对它的行为保持怀疑，不要盲目的信任它一定会返回正确的结果，或者一定会抛出方法原型中声明的异常。

对调用的代码越不熟悉，就越应该对其代码的行为保持怀疑。

**通过某种抽象机制来调用许多未知的代码，应该对在这些线程中执行的代码能否表现出正确的行为保持怀疑**。因此，这些线程应该在 try-catch 代码块中调用这些任务，这样就能捕获那些未检查的异常了，或者也可以使用 try-finally 代码块来确保框架能够知道线程非正常退出的情况，并做出正确的响应。

## 未捕获异常的处理

不同于工作线程池的主动处理方式，在 Thread API 中同样提供了 UncaughtExceptionHandler 机制。它可以检测出某个线程由于未捕获的异常而终止的情况。同时，它与 try-catch 方法是互补的，可以通过将二者结合在一起，就能有效防止线程泄露问题。

当一个线程由于未捕获异常而退出时，JVM 会将这个事件报告给应用程序提供的 UncaughtExceptionHandler 异常处理器。如果没有提供任何异常处理器，那么默认将栈信息输出到 System.err。

异常处理器如何处理未捕获异常，取决于对服务质量的需求。在运行时间较长的应用程序中，通常会为所有线程的未捕获异常指定同一个异常处理器，并且该处理器至少会将异常信息记录到日志中。

通过为线程池提供一个 ThreadPoolExecutor 的构造函数提供一个 ThreadFactory 来设置一个 UncaughtExceptionHeadler。如果没有提供捕获异常处理器或者其他的故障通知机制，那么任务会悄悄失败，从而导致极大的混乱。

标准线程池允许当发生未捕获异常时结束线程，但由于使用了一个 try-finally 代码块来接收通知，因此当线程结束时，将有新的线程来代替它。如果没有提供捕获异常处理器或者其他的故障通知机制，那么任务会悄悄失败，从而导致极大的混乱。

令人迷惑的是，通过线程池的 execute 方法提交的任务，才能将捕获的异常交给异常处理器进行处理。而通过 submit 提交的任务，无论何种异常都不会被处理，而是通过 Future.get 方法被封装重新抛出。